directive @possibleTypes(
  
  abstractType: String
  
  concreteTypes: [String!]!
) on INPUT_FIELD_DEFINITION
directive @preview(
  
  toggledBy: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
input AcceptEnterpriseAdministratorInvitationInput {
  
  clientMutationId: String
  
  invitationId: ID! @possibleTypes(concreteTypes: ["EnterpriseAdministratorInvitation"])
}
type AcceptEnterpriseAdministratorInvitationPayload {
  
  clientMutationId: String
  
  invitation: EnterpriseAdministratorInvitation
  
  message: String
}
input AcceptTopicSuggestionInput {
  
  clientMutationId: String
  
  name: String!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type AcceptTopicSuggestionPayload {
  
  clientMutationId: String
  
  topic: Topic
}
interface Actor {
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  login: String!
  
  resourcePath: URI!
  
  url: URI!
}
type ActorLocation {
  
  city: String
  
  country: String
  
  countryCode: String
  
  region: String
  
  regionCode: String
}
input AddAssigneesToAssignableInput {
  
  assignableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Assignable")
  
  assigneeIds: [ID!]! @possibleTypes(concreteTypes: ["User"])
  
  clientMutationId: String
}
type AddAssigneesToAssignablePayload {
  
  assignable: Assignable
  
  clientMutationId: String
}
input AddCommentInput {
  
  body: String!
  
  clientMutationId: String
  
  subjectId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "IssueOrPullRequest")
}
type AddCommentPayload {
  
  clientMutationId: String
  
  commentEdge: IssueCommentEdge
  
  subject: Node
  
  timelineEdge: IssueTimelineItemEdge
}
input AddLabelsToLabelableInput {
  
  clientMutationId: String
  
  labelIds: [ID!]! @possibleTypes(concreteTypes: ["Label"])
  
  labelableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Labelable")
}
type AddLabelsToLabelablePayload {
  
  clientMutationId: String
  
  labelable: Labelable
}
input AddProjectCardInput {
  
  clientMutationId: String
  
  contentId: ID @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "ProjectCardItem")
  
  note: String
  
  projectColumnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type AddProjectCardPayload {
  
  cardEdge: ProjectCardEdge
  
  clientMutationId: String
  
  projectColumn: ProjectColumn
}
input AddProjectColumnInput {
  
  clientMutationId: String
  
  name: String!
  
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
}
type AddProjectColumnPayload {
  
  clientMutationId: String
  
  columnEdge: ProjectColumnEdge
  
  project: Project
}
input AddPullRequestReviewCommentInput {
  
  body: String!
  
  clientMutationId: String
  
  commitOID: GitObjectID
  
  inReplyTo: ID @possibleTypes(concreteTypes: ["PullRequestReviewComment"])
  
  path: String
  
  position: Int
  
  pullRequestId: ID @possibleTypes(concreteTypes: ["PullRequest"])
  
  pullRequestReviewId: ID @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type AddPullRequestReviewCommentPayload {
  
  clientMutationId: String
  
  comment: PullRequestReviewComment
  
  commentEdge: PullRequestReviewCommentEdge
}
input AddPullRequestReviewInput {
  
  body: String
  
  clientMutationId: String
  
  comments: [DraftPullRequestReviewComment]
  
  commitOID: GitObjectID
  
  event: PullRequestReviewEvent
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  
  threads: [DraftPullRequestReviewThread]
}
type AddPullRequestReviewPayload {
  
  clientMutationId: String
  
  pullRequestReview: PullRequestReview
  
  reviewEdge: PullRequestReviewEdge
}
input AddPullRequestReviewThreadInput {
  
  body: String!
  
  clientMutationId: String
  
  line: Int!
  
  path: String!
  
  pullRequestId: ID @possibleTypes(concreteTypes: ["PullRequest"])
  
  pullRequestReviewId: ID @possibleTypes(concreteTypes: ["PullRequestReview"])
  
  side: DiffSide = RIGHT
  
  startLine: Int
  
  startSide: DiffSide = RIGHT
}
type AddPullRequestReviewThreadPayload {
  
  clientMutationId: String
  
  thread: PullRequestReviewThread
}
input AddReactionInput {
  
  clientMutationId: String
  
  content: ReactionContent!
  
  subjectId: ID! @possibleTypes(concreteTypes: ["CommitComment", "Issue", "IssueComment", "PullRequest", "PullRequestReview", "PullRequestReviewComment", "TeamDiscussion", "TeamDiscussionComment"], abstractType: "Reactable")
}
type AddReactionPayload {
  
  clientMutationId: String
  
  reaction: Reaction
  
  subject: Reactable
}
input AddStarInput {
  
  clientMutationId: String
  
  starrableId: ID! @possibleTypes(concreteTypes: ["Gist", "Repository", "Topic"], abstractType: "Starrable")
}
type AddStarPayload {
  
  clientMutationId: String
  
  starrable: Starrable
}
type AddedToProjectEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  project: Project @preview(toggledBy: "starfox-preview")
  
  projectCard: ProjectCard @preview(toggledBy: "starfox-preview")
  
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
type App implements Node {
  
  createdAt: DateTime!
  
  databaseId: Int
  
  description: String
  id: ID!
  
  logoBackgroundColor: String!
  
  logoUrl(
    
    size: Int
  ): URI!
  
  name: String!
  
  slug: String!
  
  updatedAt: DateTime!
  
  url: URI!
}
input ArchiveRepositoryInput {
  
  clientMutationId: String
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type ArchiveRepositoryPayload {
  
  clientMutationId: String
  
  repository: Repository
}
interface Assignable {
  
  assignees(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
}
type AssignedEvent implements Node {
  
  actor: Actor
  
  assignable: Assignable!
  
  assignee: Assignee
  
  createdAt: DateTime!
  id: ID!
  
  user: User @deprecated(reason: "Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.")
}
union Assignee = Bot | Mannequin | Organization | User
interface AuditEntry {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  operationType: OperationType
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
union AuditEntryActor = Bot | Organization | User
input AuditLogOrder {
  
  direction: OrderDirection
  
  field: AuditLogOrderField
}
enum AuditLogOrderField {
  
  CREATED_AT
}
type AutomaticBaseChangeFailedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  newBase: String!
  
  oldBase: String!
  
  pullRequest: PullRequest!
}
type AutomaticBaseChangeSucceededEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  newBase: String!
  
  oldBase: String!
  
  pullRequest: PullRequest!
}
type BaseRefChangedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  currentRefName: String!
  
  databaseId: Int
  id: ID!
  
  previousRefName: String!
  
  pullRequest: PullRequest!
}
type BaseRefDeletedEvent implements Node {
  
  actor: Actor
  
  baseRefName: String
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest
}
type BaseRefForcePushedEvent implements Node {
  
  actor: Actor
  
  afterCommit: Commit
  
  beforeCommit: Commit
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
  
  ref: Ref
}
type Blame {
  
  ranges: [BlameRange!]!
}
type BlameRange {
  
  age: Int!
  
  commit: Commit!
  
  endingLine: Int!
  
  startingLine: Int!
}
type Blob implements GitObject & Node {
  
  abbreviatedOid: String!
  
  byteSize: Int!
  
  commitResourcePath: URI!
  
  commitUrl: URI!
  id: ID!
  
  isBinary: Boolean
  
  isTruncated: Boolean!
  
  oid: GitObjectID!
  
  repository: Repository!
  
  text: String
}
type Bot implements Actor & Node & UniformResourceLocatable {
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  login: String!
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
}
type BranchProtectionRule implements Node {
  
  allowsDeletions: Boolean!
  
  allowsForcePushes: Boolean!
  
  branchProtectionRuleConflicts(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): BranchProtectionRuleConflictConnection!
  
  creator: Actor
  
  databaseId: Int
  
  dismissesStaleReviews: Boolean!
  id: ID!
  
  isAdminEnforced: Boolean!
  
  matchingRefs(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    query: String
  ): RefConnection!
  
  pattern: String!
  
  pushAllowances(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PushAllowanceConnection!
  
  repository: Repository
  
  requiredApprovingReviewCount: Int
  
  requiredStatusCheckContexts: [String]
  
  requiresApprovingReviews: Boolean!
  
  requiresCodeOwnerReviews: Boolean!
  
  requiresCommitSignatures: Boolean!
  
  requiresLinearHistory: Boolean!
  
  requiresStatusChecks: Boolean!
  
  requiresStrictStatusChecks: Boolean!
  
  restrictsPushes: Boolean!
  
  restrictsReviewDismissals: Boolean!
  
  reviewDismissalAllowances(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): ReviewDismissalAllowanceConnection!
}
type BranchProtectionRuleConflict {
  
  branchProtectionRule: BranchProtectionRule
  
  conflictingBranchProtectionRule: BranchProtectionRule
  
  ref: Ref
}
type BranchProtectionRuleConflictConnection {
  
  edges: [BranchProtectionRuleConflictEdge]
  
  nodes: [BranchProtectionRuleConflict]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type BranchProtectionRuleConflictEdge {
  
  cursor: String!
  
  node: BranchProtectionRuleConflict
}
type BranchProtectionRuleConnection {
  
  edges: [BranchProtectionRuleEdge]
  
  nodes: [BranchProtectionRule]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type BranchProtectionRuleEdge {
  
  cursor: String!
  
  node: BranchProtectionRule
}
input CancelEnterpriseAdminInvitationInput {
  
  clientMutationId: String
  
  invitationId: ID! @possibleTypes(concreteTypes: ["EnterpriseAdministratorInvitation"])
}
type CancelEnterpriseAdminInvitationPayload {
  
  clientMutationId: String
  
  invitation: EnterpriseAdministratorInvitation
  
  message: String
}
input ChangeUserStatusInput {
  
  clientMutationId: String
  
  emoji: String
  
  expiresAt: DateTime
  
  limitedAvailability: Boolean = false
  
  message: String
  
  organizationId: ID @possibleTypes(concreteTypes: ["Organization"])
}
type ChangeUserStatusPayload {
  
  clientMutationId: String
  
  status: UserStatus
}
type CheckAnnotation {
  
  annotationLevel: CheckAnnotationLevel
  
  blobUrl: URI!
  
  databaseId: Int
  
  location: CheckAnnotationSpan!
  
  message: String!
  
  path: String!
  
  rawDetails: String
  
  title: String
}
type CheckAnnotationConnection {
  
  edges: [CheckAnnotationEdge]
  
  nodes: [CheckAnnotation]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
input CheckAnnotationData {
  
  annotationLevel: CheckAnnotationLevel!
  
  location: CheckAnnotationRange!
  
  message: String!
  
  path: String!
  
  rawDetails: String
  
  title: String
}
type CheckAnnotationEdge {
  
  cursor: String!
  
  node: CheckAnnotation
}
enum CheckAnnotationLevel {
  
  FAILURE
  
  NOTICE
  
  WARNING
}
type CheckAnnotationPosition {
  
  column: Int
  
  line: Int!
}
input CheckAnnotationRange {
  
  endColumn: Int
  
  endLine: Int!
  
  startColumn: Int
  
  startLine: Int!
}
type CheckAnnotationSpan {
  
  end: CheckAnnotationPosition!
  
  start: CheckAnnotationPosition!
}
enum CheckConclusionState {
  
  ACTION_REQUIRED
  
  CANCELLED
  
  FAILURE
  
  NEUTRAL
  
  SKIPPED
  
  STALE
  
  STARTUP_FAILURE
  
  SUCCESS
  
  TIMED_OUT
}
type CheckRun implements Node & UniformResourceLocatable {
  
  annotations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CheckAnnotationConnection
  
  checkSuite: CheckSuite!
  
  completedAt: DateTime
  
  conclusion: CheckConclusionState
  
  databaseId: Int
  
  detailsUrl: URI
  
  externalId: String
  id: ID!
  
  name: String!
  
  permalink: URI!
  
  repository: Repository!
  
  resourcePath: URI!
  
  startedAt: DateTime
  
  status: CheckStatusState!
  
  summary: String
  
  text: String
  
  title: String
  
  url: URI!
}
input CheckRunAction {
  
  description: String!
  
  identifier: String!
  
  label: String!
}
type CheckRunConnection {
  
  edges: [CheckRunEdge]
  
  nodes: [CheckRun]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CheckRunEdge {
  
  cursor: String!
  
  node: CheckRun
}
input CheckRunFilter {
  
  appId: Int
  
  checkName: String
  
  checkType: CheckRunType
  
  status: CheckStatusState
}
input CheckRunOutput {
  
  annotations: [CheckAnnotationData!]
  
  images: [CheckRunOutputImage!]
  
  summary: String!
  
  text: String
  
  title: String!
}
input CheckRunOutputImage {
  
  alt: String!
  
  caption: String
  
  imageUrl: URI!
}
enum CheckRunType {
  
  ALL
  
  LATEST
}
enum CheckStatusState {
  
  COMPLETED
  
  IN_PROGRESS
  
  QUEUED
  
  REQUESTED
}
type CheckSuite implements Node {
  
  app: App
  
  branch: Ref
  
  checkRuns(
    
    after: String
    
    before: String
    
    filterBy: CheckRunFilter
    
    first: Int
    
    last: Int
  ): CheckRunConnection
  
  commit: Commit!
  
  conclusion: CheckConclusionState
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  matchingPullRequests(
    
    after: String
    
    baseRefName: String
    
    before: String
    
    first: Int
    
    headRefName: String
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [PullRequestState!]
  ): PullRequestConnection
  
  push: Push
  
  repository: Repository!
  
  resourcePath: URI!
  
  status: CheckStatusState!
  
  updatedAt: DateTime!
  
  url: URI!
}
input CheckSuiteAutoTriggerPreference {
  
  appId: ID!
  
  setting: Boolean!
}
type CheckSuiteConnection {
  
  edges: [CheckSuiteEdge]
  
  nodes: [CheckSuite]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CheckSuiteEdge {
  
  cursor: String!
  
  node: CheckSuite
}
input CheckSuiteFilter {
  
  appId: Int
  
  checkName: String
}
input ClearLabelsFromLabelableInput {
  
  clientMutationId: String
  
  labelableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Labelable")
}
type ClearLabelsFromLabelablePayload {
  
  clientMutationId: String
  
  labelable: Labelable
}
input CloneProjectInput {
  
  body: String
  
  clientMutationId: String
  
  includeWorkflows: Boolean!
  
  name: String!
  
  public: Boolean
  
  sourceId: ID! @possibleTypes(concreteTypes: ["Project"])
  
  targetOwnerId: ID! @possibleTypes(concreteTypes: ["Organization", "Repository", "User"], abstractType: "ProjectOwner")
}
type CloneProjectPayload {
  
  clientMutationId: String
  
  jobStatusId: String
  
  project: Project
}
input CloneTemplateRepositoryInput {
  
  clientMutationId: String
  
  description: String
  
  includeAllBranches: Boolean = false
  
  name: String!
  
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "RepositoryOwner")
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  visibility: RepositoryVisibility!
}
type CloneTemplateRepositoryPayload {
  
  clientMutationId: String
  
  repository: Repository
}
interface Closable {
  
  closed: Boolean!
  
  closedAt: DateTime
}
input CloseIssueInput {
  
  clientMutationId: String
  
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type CloseIssuePayload {
  
  clientMutationId: String
  
  issue: Issue
}
input ClosePullRequestInput {
  
  clientMutationId: String
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type ClosePullRequestPayload {
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
type ClosedEvent implements Node & UniformResourceLocatable {
  
  actor: Actor
  
  closable: Closable!
  
  closer: Closer
  
  createdAt: DateTime!
  id: ID!
  
  resourcePath: URI!
  
  url: URI!
}
union Closer = Commit | PullRequest
type CodeOfConduct implements Node {
  
  body: String
  id: ID!
  
  key: String!
  
  name: String!
  
  resourcePath: URI
  
  url: URI
}
enum CollaboratorAffiliation {
  
  ALL
  
  DIRECT
  
  OUTSIDE
}
interface Comment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  lastEditedAt: DateTime
  
  publishedAt: DateTime
  
  updatedAt: DateTime!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerDidAuthor: Boolean!
}
enum CommentAuthorAssociation {
  
  COLLABORATOR
  
  CONTRIBUTOR
  
  FIRST_TIMER
  
  FIRST_TIME_CONTRIBUTOR
  
  MANNEQUIN
  
  MEMBER
  
  NONE
  
  OWNER
}
enum CommentCannotUpdateReason {
  
  ARCHIVED
  
  DENIED
  
  INSUFFICIENT_ACCESS
  
  LOCKED
  
  LOGIN_REQUIRED
  
  MAINTENANCE
  
  VERIFIED_EMAIL_REQUIRED
}
type CommentDeletedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  
  deletedCommentAuthor: Actor
  id: ID!
}
type Commit implements GitObject & Node & Subscribable & UniformResourceLocatable {
  
  abbreviatedOid: String!
  
  additions: Int!
  
  associatedPullRequests(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: PullRequestOrder = {field: CREATED_AT, direction: ASC}
  ): PullRequestConnection
  
  author: GitActor
  
  authoredByCommitter: Boolean!
  
  authoredDate: DateTime!
  
  authors(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): GitActorConnection!
  
  blame(
    
    path: String!
  ): Blame!
  
  changedFiles: Int!
  
  checkSuites(
    
    after: String
    
    before: String
    
    filterBy: CheckSuiteFilter
    
    first: Int
    
    last: Int
  ): CheckSuiteConnection
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CommitCommentConnection!
  
  commitResourcePath: URI!
  
  commitUrl: URI!
  
  committedDate: DateTime!
  
  committedViaWeb: Boolean!
  
  committer: GitActor
  
  deletions: Int!
  
  deployments(
    
    after: String
    
    before: String
    
    environments: [String!]
    
    first: Int
    
    last: Int
    
    orderBy: DeploymentOrder = {field: CREATED_AT, direction: ASC}
  ): DeploymentConnection
  
  file(
    
    path: String!
  ): TreeEntry
  
  history(
    
    after: String
    
    author: CommitAuthor
    
    before: String
    
    first: Int
    
    last: Int
    
    path: String
    
    since: GitTimestamp
    
    until: GitTimestamp
  ): CommitHistoryConnection!
  id: ID!
  
  message: String!
  
  messageBody: String!
  
  messageBodyHTML: HTML!
  
  messageHeadline: String!
  
  messageHeadlineHTML: HTML!
  
  oid: GitObjectID!
  
  onBehalfOf: Organization
  
  parents(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CommitConnection!
  
  pushedDate: DateTime
  
  repository: Repository!
  
  resourcePath: URI!
  
  signature: GitSignature
  
  status: Status
  
  statusCheckRollup: StatusCheckRollup
  
  submodules(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): SubmoduleConnection!
  
  tarballUrl: URI!
  
  tree: Tree!
  
  treeResourcePath: URI!
  
  treeUrl: URI!
  
  url: URI!
  
  viewerCanSubscribe: Boolean!
  
  viewerSubscription: SubscriptionState
  
  zipballUrl: URI!
}
input CommitAuthor {
  
  emails: [String!]
  
  id: ID
}
type CommitComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  commit: Commit
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isMinimized: Boolean!
  
  lastEditedAt: DateTime
  
  minimizedReason: String
  
  path: String
  
  position: Int
  
  publishedAt: DateTime
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanMinimize: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
}
type CommitCommentConnection {
  
  edges: [CommitCommentEdge]
  
  nodes: [CommitComment]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CommitCommentEdge {
  
  cursor: String!
  
  node: CommitComment
}
type CommitCommentThread implements Node & RepositoryNode {
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CommitCommentConnection!
  
  commit: Commit
  id: ID!
  
  path: String
  
  position: Int
  
  repository: Repository!
}
type CommitConnection {
  
  edges: [CommitEdge]
  
  nodes: [Commit]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
input CommitContributionOrder {
  
  direction: OrderDirection!
  
  field: CommitContributionOrderField!
}
enum CommitContributionOrderField {
  
  COMMIT_COUNT
  
  OCCURRED_AT
}
type CommitContributionsByRepository {
  
  contributions(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: CommitContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedCommitContributionConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  url: URI!
}
type CommitEdge {
  
  cursor: String!
  
  node: Commit
}
type CommitHistoryConnection {
  
  edges: [CommitEdge]
  
  nodes: [Commit]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ConnectedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  isCrossRepository: Boolean!
  
  source: ReferencedSubject!
  
  subject: ReferencedSubject!
}
type ContentAttachment {
  
  body: String!
  
  contentReference: ContentReference!
  
  databaseId: Int!
  id: ID!
  
  title: String!
}
type ContentReference {
  
  databaseId: Int!
  id: ID!
  
  reference: String!
}
interface Contribution {
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type ContributionCalendar {
  
  colors: [String!]!
  
  isHalloween: Boolean!
  
  months: [ContributionCalendarMonth!]!
  
  totalContributions: Int!
  
  weeks: [ContributionCalendarWeek!]!
}
type ContributionCalendarDay {
  
  color: String!
  
  contributionCount: Int!
  
  date: Date!
  
  weekday: Int!
}
type ContributionCalendarMonth {
  
  firstDay: Date!
  
  name: String!
  
  totalWeeks: Int!
  
  year: Int!
}
type ContributionCalendarWeek {
  
  contributionDays: [ContributionCalendarDay!]!
  
  firstDay: Date!
}
input ContributionOrder {
  
  direction: OrderDirection!
}
type ContributionsCollection {
  
  commitContributionsByRepository(
    
    maxRepositories: Int = 25
  ): [CommitContributionsByRepository!]!
  
  contributionCalendar: ContributionCalendar!
  
  contributionYears: [Int!]!
  
  doesEndInCurrentMonth: Boolean!
  
  earliestRestrictedContributionDate: Date
  
  endedAt: DateTime!
  
  firstIssueContribution: CreatedIssueOrRestrictedContribution
  
  firstPullRequestContribution: CreatedPullRequestOrRestrictedContribution
  
  firstRepositoryContribution: CreatedRepositoryOrRestrictedContribution
  
  hasActivityInThePast: Boolean!
  
  hasAnyContributions: Boolean!
  
  hasAnyRestrictedContributions: Boolean!
  
  isSingleDay: Boolean!
  
  issueContributions(
    
    after: String
    
    before: String
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedIssueContributionConnection!
  
  issueContributionsByRepository(
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
    
    maxRepositories: Int = 25
  ): [IssueContributionsByRepository!]!
  
  joinedGitHubContribution: JoinedGitHubContribution
  
  latestRestrictedContributionDate: Date
  
  mostRecentCollectionWithActivity: ContributionsCollection
  
  mostRecentCollectionWithoutActivity: ContributionsCollection
  
  popularIssueContribution: CreatedIssueContribution
  
  popularPullRequestContribution: CreatedPullRequestContribution
  
  pullRequestContributions(
    
    after: String
    
    before: String
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestContributionConnection!
  
  pullRequestContributionsByRepository(
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
    
    maxRepositories: Int = 25
  ): [PullRequestContributionsByRepository!]!
  
  pullRequestReviewContributions(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestReviewContributionConnection!
  
  pullRequestReviewContributionsByRepository(
    
    maxRepositories: Int = 25
  ): [PullRequestReviewContributionsByRepository!]!
  
  repositoryContributions(
    
    after: String
    
    before: String
    
    excludeFirst: Boolean = false
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedRepositoryContributionConnection!
  
  restrictedContributionsCount: Int!
  
  startedAt: DateTime!
  
  totalCommitContributions: Int!
  
  totalIssueContributions(
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
  ): Int!
  
  totalPullRequestContributions(
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
  ): Int!
  
  totalPullRequestReviewContributions: Int!
  
  totalRepositoriesWithContributedCommits: Int!
  
  totalRepositoriesWithContributedIssues(
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
  ): Int!
  
  totalRepositoriesWithContributedPullRequestReviews: Int!
  
  totalRepositoriesWithContributedPullRequests(
    
    excludeFirst: Boolean = false
    
    excludePopular: Boolean = false
  ): Int!
  
  totalRepositoryContributions(
    
    excludeFirst: Boolean = false
  ): Int!
  
  user: User!
}
input ConvertProjectCardNoteToIssueInput {
  
  body: String
  
  clientMutationId: String
  
  projectCardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  title: String
}
type ConvertProjectCardNoteToIssuePayload {
  
  clientMutationId: String
  
  projectCard: ProjectCard
}
type ConvertToDraftEvent implements Node & UniformResourceLocatable {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
  
  resourcePath: URI!
  
  url: URI!
}
type ConvertedNoteToIssueEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  project: Project @preview(toggledBy: "starfox-preview")
  
  projectCard: ProjectCard @preview(toggledBy: "starfox-preview")
  
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
input CreateBranchProtectionRuleInput {
  
  allowsDeletions: Boolean
  
  allowsForcePushes: Boolean
  
  clientMutationId: String
  
  dismissesStaleReviews: Boolean
  
  isAdminEnforced: Boolean
  
  pattern: String!
  
  pushActorIds: [ID!]
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  requiredApprovingReviewCount: Int
  
  requiredStatusCheckContexts: [String!]
  
  requiresApprovingReviews: Boolean
  
  requiresCodeOwnerReviews: Boolean
  
  requiresCommitSignatures: Boolean
  
  requiresLinearHistory: Boolean
  
  requiresStatusChecks: Boolean
  
  requiresStrictStatusChecks: Boolean
  
  restrictsPushes: Boolean
  
  restrictsReviewDismissals: Boolean
  
  reviewDismissalActorIds: [ID!]
}
type CreateBranchProtectionRulePayload {
  
  branchProtectionRule: BranchProtectionRule
  
  clientMutationId: String
}
input CreateCheckRunInput {
  
  actions: [CheckRunAction!]
  
  clientMutationId: String
  
  completedAt: DateTime
  
  conclusion: CheckConclusionState
  
  detailsUrl: URI
  
  externalId: String
  
  headSha: GitObjectID!
  
  name: String!
  
  output: CheckRunOutput
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  startedAt: DateTime
  
  status: RequestableCheckStatusState
}
type CreateCheckRunPayload {
  
  checkRun: CheckRun
  
  clientMutationId: String
}
input CreateCheckSuiteInput {
  
  clientMutationId: String
  
  headSha: GitObjectID!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateCheckSuitePayload {
  
  checkSuite: CheckSuite
  
  clientMutationId: String
}
input CreateContentAttachmentInput {
  
  body: String!
  
  clientMutationId: String
  
  contentReferenceId: ID! @possibleTypes(concreteTypes: ["ContentReference"])
  
  title: String!
}
type CreateContentAttachmentPayload {
  
  clientMutationId: String
  
  contentAttachment: ContentAttachment
}
input CreateDeploymentInput @preview(toggledBy: "flash-preview") {
  
  autoMerge: Boolean = true
  
  clientMutationId: String
  
  description: String = ""
  
  environment: String = "production"
  
  payload: String = "{}"
  
  refId: ID! @possibleTypes(concreteTypes: ["Ref"])
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  requiredContexts: [String!]
  
  task: String = "deploy"
}
type CreateDeploymentPayload @preview(toggledBy: "flash-preview") {
  
  autoMerged: Boolean
  
  clientMutationId: String
  
  deployment: Deployment
}
input CreateDeploymentStatusInput @preview(toggledBy: "flash-preview") {
  
  autoInactive: Boolean = true
  
  clientMutationId: String
  
  deploymentId: ID! @possibleTypes(concreteTypes: ["Deployment"])
  
  description: String = ""
  
  environment: String
  
  environmentUrl: String = ""
  
  logUrl: String = ""
  
  state: DeploymentStatusState!
}
type CreateDeploymentStatusPayload @preview(toggledBy: "flash-preview") {
  
  clientMutationId: String
  
  deploymentStatus: DeploymentStatus
}
input CreateEnterpriseOrganizationInput {
  
  adminLogins: [String!]!
  
  billingEmail: String!
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  login: String!
  
  profileName: String!
}
type CreateEnterpriseOrganizationPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  organization: Organization
}
input CreateIpAllowListEntryInput {
  
  allowListValue: String!
  
  clientMutationId: String
  
  isActive: Boolean!
  
  name: String
  
  ownerId: ID! @possibleTypes(concreteTypes: ["Enterprise", "Organization"], abstractType: "IpAllowListOwner")
}
type CreateIpAllowListEntryPayload {
  
  clientMutationId: String
  
  ipAllowListEntry: IpAllowListEntry
}
input CreateIssueInput {
  
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  
  body: String
  
  clientMutationId: String
  
  issueTemplate: String
  
  labelIds: [ID!] @possibleTypes(concreteTypes: ["Label"])
  
  milestoneId: ID @possibleTypes(concreteTypes: ["Milestone"])
  
  projectIds: [ID!] @possibleTypes(concreteTypes: ["Project"])
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  title: String!
}
type CreateIssuePayload {
  
  clientMutationId: String
  
  issue: Issue
}
input CreateLabelInput @preview(toggledBy: "bane-preview") {
  
  clientMutationId: String
  
  color: String!
  
  description: String
  
  name: String!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateLabelPayload @preview(toggledBy: "bane-preview") {
  
  clientMutationId: String
  
  label: Label
}
input CreateProjectInput {
  
  body: String
  
  clientMutationId: String
  
  name: String!
  
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization", "Repository", "User"], abstractType: "ProjectOwner")
  
  repositoryIds: [ID!] @possibleTypes(concreteTypes: ["Repository"])
  
  template: ProjectTemplate
}
type CreateProjectPayload {
  
  clientMutationId: String
  
  project: Project
}
input CreatePullRequestInput {
  
  baseRefName: String!
  
  body: String
  
  clientMutationId: String
  
  draft: Boolean = false
  
  headRefName: String!
  
  maintainerCanModify: Boolean = true
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  title: String!
}
type CreatePullRequestPayload {
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
input CreateRefInput {
  
  clientMutationId: String
  
  name: String!
  
  oid: GitObjectID!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateRefPayload {
  
  clientMutationId: String
  
  ref: Ref
}
input CreateRepositoryInput {
  
  clientMutationId: String
  
  description: String
  
  hasIssuesEnabled: Boolean = true
  
  hasWikiEnabled: Boolean = false
  
  homepageUrl: URI
  
  name: String!
  
  ownerId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "RepositoryOwner")
  
  teamId: ID @possibleTypes(concreteTypes: ["Team"])
  
  template: Boolean = false
  
  visibility: RepositoryVisibility!
}
type CreateRepositoryPayload {
  
  clientMutationId: String
  
  repository: Repository
}
input CreateTeamDiscussionCommentInput {
  
  body: String!
  
  clientMutationId: String
  
  discussionId: ID! @possibleTypes(concreteTypes: ["TeamDiscussion"])
}
type CreateTeamDiscussionCommentPayload {
  
  clientMutationId: String
  
  teamDiscussionComment: TeamDiscussionComment
}
input CreateTeamDiscussionInput {
  
  body: String!
  
  clientMutationId: String
  
  private: Boolean
  
  teamId: ID! @possibleTypes(concreteTypes: ["Team"])
  
  title: String!
}
type CreateTeamDiscussionPayload {
  
  clientMutationId: String
  
  teamDiscussion: TeamDiscussion
}
type CreatedCommitContribution implements Contribution {
  
  commitCount: Int!
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  repository: Repository!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type CreatedCommitContributionConnection {
  
  edges: [CreatedCommitContributionEdge]
  
  nodes: [CreatedCommitContribution]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CreatedCommitContributionEdge {
  
  cursor: String!
  
  node: CreatedCommitContribution
}
type CreatedIssueContribution implements Contribution {
  
  isRestricted: Boolean!
  
  issue: Issue!
  
  occurredAt: DateTime!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type CreatedIssueContributionConnection {
  
  edges: [CreatedIssueContributionEdge]
  
  nodes: [CreatedIssueContribution]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CreatedIssueContributionEdge {
  
  cursor: String!
  
  node: CreatedIssueContribution
}
union CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution
type CreatedPullRequestContribution implements Contribution {
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  pullRequest: PullRequest!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type CreatedPullRequestContributionConnection {
  
  edges: [CreatedPullRequestContributionEdge]
  
  nodes: [CreatedPullRequestContribution]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CreatedPullRequestContributionEdge {
  
  cursor: String!
  
  node: CreatedPullRequestContribution
}
union CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution
type CreatedPullRequestReviewContribution implements Contribution {
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  pullRequest: PullRequest!
  
  pullRequestReview: PullRequestReview!
  
  repository: Repository!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type CreatedPullRequestReviewContributionConnection {
  
  edges: [CreatedPullRequestReviewContributionEdge]
  
  nodes: [CreatedPullRequestReviewContribution]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CreatedPullRequestReviewContributionEdge {
  
  cursor: String!
  
  node: CreatedPullRequestReviewContribution
}
type CreatedRepositoryContribution implements Contribution {
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  repository: Repository!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type CreatedRepositoryContributionConnection {
  
  edges: [CreatedRepositoryContributionEdge]
  
  nodes: [CreatedRepositoryContribution]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type CreatedRepositoryContributionEdge {
  
  cursor: String!
  
  node: CreatedRepositoryContribution
}
union CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution
type CrossReferencedEvent implements Node & UniformResourceLocatable {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  isCrossRepository: Boolean!
  
  referencedAt: DateTime!
  
  resourcePath: URI!
  
  source: ReferencedSubject!
  
  target: ReferencedSubject!
  
  url: URI!
  
  willCloseTarget: Boolean!
}
scalar Date
scalar DateTime
input DeclineTopicSuggestionInput {
  
  clientMutationId: String
  
  name: String!
  
  reason: TopicSuggestionDeclineReason!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type DeclineTopicSuggestionPayload {
  
  clientMutationId: String
  
  topic: Topic
}
enum DefaultRepositoryPermissionField {
  
  ADMIN
  
  NONE
  
  READ
  
  WRITE
}
interface Deletable {
  
  viewerCanDelete: Boolean!
}
input DeleteBranchProtectionRuleInput {
  
  branchProtectionRuleId: ID! @possibleTypes(concreteTypes: ["BranchProtectionRule"])
  
  clientMutationId: String
}
type DeleteBranchProtectionRulePayload {
  
  clientMutationId: String
}
input DeleteDeploymentInput {
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["Deployment"])
}
type DeleteDeploymentPayload {
  
  clientMutationId: String
}
input DeleteIpAllowListEntryInput {
  
  clientMutationId: String
  
  ipAllowListEntryId: ID! @possibleTypes(concreteTypes: ["IpAllowListEntry"])
}
type DeleteIpAllowListEntryPayload {
  
  clientMutationId: String
  
  ipAllowListEntry: IpAllowListEntry
}
input DeleteIssueCommentInput {
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["IssueComment"])
}
type DeleteIssueCommentPayload {
  
  clientMutationId: String
}
input DeleteIssueInput {
  
  clientMutationId: String
  
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type DeleteIssuePayload {
  
  clientMutationId: String
  
  repository: Repository
}
input DeleteLabelInput @preview(toggledBy: "bane-preview") {
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["Label"])
}
type DeleteLabelPayload @preview(toggledBy: "bane-preview") {
  
  clientMutationId: String
}
input DeletePackageVersionInput {
  
  clientMutationId: String
  
  packageVersionId: ID! @possibleTypes(concreteTypes: ["PackageVersion"])
}
type DeletePackageVersionPayload {
  
  clientMutationId: String
  
  success: Boolean
}
input DeleteProjectCardInput {
  
  cardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
  
  clientMutationId: String
}
type DeleteProjectCardPayload {
  
  clientMutationId: String
  
  column: ProjectColumn
  
  deletedCardId: ID
}
input DeleteProjectColumnInput {
  
  clientMutationId: String
  
  columnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type DeleteProjectColumnPayload {
  
  clientMutationId: String
  
  deletedColumnId: ID
  
  project: Project
}
input DeleteProjectInput {
  
  clientMutationId: String
  
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
}
type DeleteProjectPayload {
  
  clientMutationId: String
  
  owner: ProjectOwner
}
input DeletePullRequestReviewCommentInput {
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["PullRequestReviewComment"])
}
type DeletePullRequestReviewCommentPayload {
  
  clientMutationId: String
  
  pullRequestReview: PullRequestReview
}
input DeletePullRequestReviewInput {
  
  clientMutationId: String
  
  pullRequestReviewId: ID! @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type DeletePullRequestReviewPayload {
  
  clientMutationId: String
  
  pullRequestReview: PullRequestReview
}
input DeleteRefInput {
  
  clientMutationId: String
  
  refId: ID! @possibleTypes(concreteTypes: ["Ref"])
}
type DeleteRefPayload {
  
  clientMutationId: String
}
input DeleteTeamDiscussionCommentInput {
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussionComment"])
}
type DeleteTeamDiscussionCommentPayload {
  
  clientMutationId: String
}
input DeleteTeamDiscussionInput {
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussion"])
}
type DeleteTeamDiscussionPayload {
  
  clientMutationId: String
}
type DemilestonedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  milestoneTitle: String!
  
  subject: MilestoneItem!
}
type DependencyGraphDependency @preview(toggledBy: "hawkgirl-preview") {
  
  hasDependencies: Boolean!
  
  packageManager: String
  
  packageName: String!
  
  repository: Repository
  
  requirements: String!
}
type DependencyGraphDependencyConnection @preview(toggledBy: "hawkgirl-preview") {
  
  edges: [DependencyGraphDependencyEdge]
  
  nodes: [DependencyGraphDependency]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type DependencyGraphDependencyEdge @preview(toggledBy: "hawkgirl-preview") {
  
  cursor: String!
  
  node: DependencyGraphDependency
}
type DependencyGraphManifest implements Node @preview(toggledBy: "hawkgirl-preview") {
  
  blobPath: String!
  
  dependencies(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): DependencyGraphDependencyConnection
  
  dependenciesCount: Int
  
  exceedsMaxSize: Boolean!
  
  filename: String!
  id: ID!
  
  parseable: Boolean!
  
  repository: Repository!
}
type DependencyGraphManifestConnection @preview(toggledBy: "hawkgirl-preview") {
  
  edges: [DependencyGraphManifestEdge]
  
  nodes: [DependencyGraphManifest]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type DependencyGraphManifestEdge @preview(toggledBy: "hawkgirl-preview") {
  
  cursor: String!
  
  node: DependencyGraphManifest
}
type DeployKey implements Node {
  
  createdAt: DateTime!
  id: ID!
  
  key: String!
  
  readOnly: Boolean!
  
  title: String!
  
  verified: Boolean!
}
type DeployKeyConnection {
  
  edges: [DeployKeyEdge]
  
  nodes: [DeployKey]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type DeployKeyEdge {
  
  cursor: String!
  
  node: DeployKey
}
type DeployedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  
  deployment: Deployment!
  id: ID!
  
  pullRequest: PullRequest!
  
  ref: Ref
}
type Deployment implements Node {
  
  commit: Commit
  
  commitOid: String!
  
  createdAt: DateTime!
  
  creator: Actor!
  
  databaseId: Int
  
  description: String
  
  environment: String
  id: ID!
  
  latestEnvironment: String
  
  latestStatus: DeploymentStatus
  
  originalEnvironment: String
  
  payload: String
  
  ref: Ref
  
  repository: Repository!
  
  state: DeploymentState
  
  statuses(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): DeploymentStatusConnection
  
  task: String
  
  updatedAt: DateTime!
}
type DeploymentConnection {
  
  edges: [DeploymentEdge]
  
  nodes: [Deployment]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type DeploymentEdge {
  
  cursor: String!
  
  node: Deployment
}
type DeploymentEnvironmentChangedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  deploymentStatus: DeploymentStatus!
  id: ID!
  
  pullRequest: PullRequest!
}
input DeploymentOrder {
  
  direction: OrderDirection!
  
  field: DeploymentOrderField!
}
enum DeploymentOrderField {
  
  CREATED_AT
}
enum DeploymentState {
  
  ABANDONED
  
  ACTIVE
  
  DESTROYED
  
  ERROR
  
  FAILURE
  
  INACTIVE
  
  IN_PROGRESS
  
  PENDING
  
  QUEUED
  
  WAITING
}
type DeploymentStatus implements Node {
  
  createdAt: DateTime!
  
  creator: Actor!
  
  deployment: Deployment!
  
  description: String
  
  environment: String @preview(toggledBy: "flash-preview")
  
  environmentUrl: URI
  id: ID!
  
  logUrl: URI
  
  state: DeploymentStatusState!
  
  updatedAt: DateTime!
}
type DeploymentStatusConnection {
  
  edges: [DeploymentStatusEdge]
  
  nodes: [DeploymentStatus]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type DeploymentStatusEdge {
  
  cursor: String!
  
  node: DeploymentStatus
}
enum DeploymentStatusState {
  
  ERROR
  
  FAILURE
  
  INACTIVE
  
  IN_PROGRESS
  
  PENDING
  
  QUEUED
  
  SUCCESS
}
enum DiffSide {
  
  LEFT
  
  RIGHT
}
type DisconnectedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  isCrossRepository: Boolean!
  
  source: ReferencedSubject!
  
  subject: ReferencedSubject!
}
input DismissPullRequestReviewInput {
  
  clientMutationId: String
  
  message: String!
  
  pullRequestReviewId: ID! @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type DismissPullRequestReviewPayload {
  
  clientMutationId: String
  
  pullRequestReview: PullRequestReview
}
input DraftPullRequestReviewComment {
  
  body: String!
  
  path: String!
  
  position: Int!
}
input DraftPullRequestReviewThread {
  
  body: String!
  
  line: Int!
  
  path: String!
  
  side: DiffSide = RIGHT
  
  startLine: Int
  
  startSide: DiffSide = RIGHT
}
type Enterprise implements Node {
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  billingInfo: EnterpriseBillingInfo
  
  createdAt: DateTime!
  
  databaseId: Int
  
  description: String
  
  descriptionHTML: HTML!
  id: ID!
  
  location: String
  
  members(
    
    after: String
    
    before: String
    
    deployment: EnterpriseUserDeployment
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
    
    organizationLogins: [String!]
    
    query: String
    
    role: EnterpriseUserAccountMembershipRole
  ): EnterpriseMemberConnection!
  
  name: String!
  
  organizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    query: String
  ): OrganizationConnection!
  
  ownerInfo: EnterpriseOwnerInfo
  
  resourcePath: URI!
  
  slug: String!
  
  url: URI!
  
  userAccounts(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): EnterpriseUserAccountConnection!
  
  viewerIsAdmin: Boolean!
  
  websiteUrl: URI
}
type EnterpriseAdministratorConnection {
  
  edges: [EnterpriseAdministratorEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseAdministratorEdge {
  
  cursor: String!
  
  node: User
  
  role: EnterpriseAdministratorRole!
}
type EnterpriseAdministratorInvitation implements Node {
  
  createdAt: DateTime!
  
  email: String
  
  enterprise: Enterprise!
  id: ID!
  
  invitee: User
  
  inviter: User
  
  role: EnterpriseAdministratorRole!
}
type EnterpriseAdministratorInvitationConnection {
  
  edges: [EnterpriseAdministratorInvitationEdge]
  
  nodes: [EnterpriseAdministratorInvitation]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseAdministratorInvitationEdge {
  
  cursor: String!
  
  node: EnterpriseAdministratorInvitation
}
input EnterpriseAdministratorInvitationOrder {
  
  direction: OrderDirection!
  
  field: EnterpriseAdministratorInvitationOrderField!
}
enum EnterpriseAdministratorInvitationOrderField {
  
  CREATED_AT
}
enum EnterpriseAdministratorRole {
  
  BILLING_MANAGER
  
  OWNER
}
interface EnterpriseAuditEntryData {
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
}
type EnterpriseBillingInfo {
  
  allLicensableUsersCount: Int!
  
  assetPacks: Int!
  
  availableSeats: Int! @deprecated(reason: "`availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.")
  
  bandwidthQuota: Float!
  
  bandwidthUsage: Float!
  
  bandwidthUsagePercentage: Int!
  
  seats: Int! @deprecated(reason: "`seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.")
  
  storageQuota: Float!
  
  storageUsage: Float!
  
  storageUsagePercentage: Int!
  
  totalAvailableLicenses: Int!
  
  totalLicenses: Int!
}
enum EnterpriseDefaultRepositoryPermissionSettingValue {
  
  ADMIN
  
  NONE
  
  NO_POLICY
  
  READ
  
  WRITE
}
enum EnterpriseEnabledDisabledSettingValue {
  
  DISABLED
  
  ENABLED
  
  NO_POLICY
}
enum EnterpriseEnabledSettingValue {
  
  ENABLED
  
  NO_POLICY
}
type EnterpriseIdentityProvider implements Node {
  
  digestMethod: SamlDigestAlgorithm
  
  enterprise: Enterprise
  
  externalIdentities(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): ExternalIdentityConnection!
  id: ID!
  
  idpCertificate: X509Certificate
  
  issuer: String
  
  recoveryCodes: [String!]
  
  signatureMethod: SamlSignatureAlgorithm
  
  ssoUrl: URI
}
union EnterpriseMember = EnterpriseUserAccount | User
type EnterpriseMemberConnection {
  
  edges: [EnterpriseMemberEdge]
  
  nodes: [EnterpriseMember]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseMemberEdge {
  
  cursor: String!
  
  isUnlicensed: Boolean! @deprecated(reason: "All members consume a license Removal on 2021-01-01 UTC.")
  
  node: EnterpriseMember
}
input EnterpriseMemberOrder {
  
  direction: OrderDirection!
  
  field: EnterpriseMemberOrderField!
}
enum EnterpriseMemberOrderField {
  
  CREATED_AT
  
  LOGIN
}
enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  
  ALL
  
  DISABLED
  
  NO_POLICY
  
  PRIVATE
  
  PUBLIC
}
enum EnterpriseMembersCanMakePurchasesSettingValue {
  
  DISABLED
  
  ENABLED
}
type EnterpriseOrganizationMembershipConnection {
  
  edges: [EnterpriseOrganizationMembershipEdge]
  
  nodes: [Organization]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseOrganizationMembershipEdge {
  
  cursor: String!
  
  node: Organization
  
  role: EnterpriseUserAccountMembershipRole!
}
type EnterpriseOutsideCollaboratorConnection {
  
  edges: [EnterpriseOutsideCollaboratorEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseOutsideCollaboratorEdge {
  
  cursor: String!
  
  isUnlicensed: Boolean! @deprecated(reason: "All outside collaborators consume a license Removal on 2021-01-01 UTC.")
  
  node: User
  
  repositories(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: RepositoryOrder = {field: NAME, direction: ASC}
  ): EnterpriseRepositoryInfoConnection!
}
type EnterpriseOwnerInfo {
  
  admins(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
    
    query: String
    
    role: EnterpriseAdministratorRole
  ): EnterpriseAdministratorConnection!
  
  affiliatedUsersWithTwoFactorDisabled(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
  
  affiliatedUsersWithTwoFactorDisabledExist: Boolean!
  
  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue!
  
  allowPrivateRepositoryForkingSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue!
  
  defaultRepositoryPermissionSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: DefaultRepositoryPermissionField!
  ): OrganizationConnection!
  
  enterpriseServerInstallations(
    
    after: String
    
    before: String
    
    connectedOnly: Boolean = false
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseServerInstallationOrder = {field: HOST_NAME, direction: ASC}
  ): EnterpriseServerInstallationConnection!
  
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue!
  
  ipAllowListEntries(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: IpAllowListEntryOrder = {field: ALLOW_LIST_VALUE, direction: ASC}
  ): IpAllowListEntryConnection!
  
  isUpdatingDefaultRepositoryPermission: Boolean!
  
  isUpdatingTwoFactorRequirement: Boolean!
  
  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue!
  
  membersCanChangeRepositoryVisibilitySettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  membersCanCreateInternalRepositoriesSetting: Boolean
  
  membersCanCreatePrivateRepositoriesSetting: Boolean
  
  membersCanCreatePublicRepositoriesSetting: Boolean
  
  membersCanCreateRepositoriesSetting: EnterpriseMembersCanCreateRepositoriesSettingValue
  
  membersCanCreateRepositoriesSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: OrganizationMembersCanCreateRepositoriesSettingValue!
  ): OrganizationConnection!
  
  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue!
  
  membersCanDeleteIssuesSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue!
  
  membersCanDeleteRepositoriesSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue!
  
  membersCanInviteCollaboratorsSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue!
  
  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue!
  
  membersCanUpdateProtectedBranchesSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue!
  
  membersCanViewDependencyInsightsSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue!
  
  organizationProjectsSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  outsideCollaborators(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    login: String
    
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
    
    query: String
    
    visibility: RepositoryVisibility
  ): EnterpriseOutsideCollaboratorConnection!
  
  pendingAdminInvitations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseAdministratorInvitationOrder = {field: CREATED_AT, direction: DESC}
    
    query: String
    
    role: EnterpriseAdministratorRole
  ): EnterpriseAdministratorInvitationConnection!
  
  pendingCollaboratorInvitations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: RepositoryInvitationOrder = {field: CREATED_AT, direction: DESC}
    
    query: String
  ): RepositoryInvitationConnection!
  
  pendingCollaborators(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: RepositoryInvitationOrder = {field: CREATED_AT, direction: DESC}
    
    query: String
  ): EnterprisePendingCollaboratorConnection! @deprecated(reason: "Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.")
  
  pendingMemberInvitations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    query: String
  ): EnterprisePendingMemberInvitationConnection!
  
  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue!
  
  repositoryProjectsSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  samlIdentityProvider: EnterpriseIdentityProvider
  
  samlIdentityProviderSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: IdentityProviderConfigurationState!
  ): OrganizationConnection!
  
  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue!
  
  teamDiscussionsSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
  
  twoFactorRequiredSetting: EnterpriseEnabledSettingValue!
  
  twoFactorRequiredSettingOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    value: Boolean!
  ): OrganizationConnection!
}
type EnterprisePendingCollaboratorConnection {
  
  edges: [EnterprisePendingCollaboratorEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterprisePendingCollaboratorEdge {
  
  cursor: String!
  
  isUnlicensed: Boolean! @deprecated(reason: "All pending collaborators consume a license Removal on 2021-01-01 UTC.")
  
  node: User
  
  repositories(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: RepositoryOrder = {field: NAME, direction: ASC}
  ): EnterpriseRepositoryInfoConnection!
}
type EnterprisePendingMemberInvitationConnection {
  
  edges: [EnterprisePendingMemberInvitationEdge]
  
  nodes: [OrganizationInvitation]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
  
  totalUniqueUserCount: Int!
}
type EnterprisePendingMemberInvitationEdge {
  
  cursor: String!
  
  isUnlicensed: Boolean! @deprecated(reason: "All pending members consume a license Removal on 2020-07-01 UTC.")
  
  node: OrganizationInvitation
}
type EnterpriseRepositoryInfo implements Node {
  id: ID!
  
  isPrivate: Boolean!
  
  name: String!
  
  nameWithOwner: String!
}
type EnterpriseRepositoryInfoConnection {
  
  edges: [EnterpriseRepositoryInfoEdge]
  
  nodes: [EnterpriseRepositoryInfo]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseRepositoryInfoEdge {
  
  cursor: String!
  
  node: EnterpriseRepositoryInfo
}
type EnterpriseServerInstallation implements Node {
  
  createdAt: DateTime!
  
  customerName: String!
  
  hostName: String!
  id: ID!
  
  isConnected: Boolean!
  
  updatedAt: DateTime!
  
  userAccounts(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseServerUserAccountOrder = {field: LOGIN, direction: ASC}
  ): EnterpriseServerUserAccountConnection!
  
  userAccountsUploads(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseServerUserAccountsUploadOrder = {field: CREATED_AT, direction: DESC}
  ): EnterpriseServerUserAccountsUploadConnection!
}
type EnterpriseServerInstallationConnection {
  
  edges: [EnterpriseServerInstallationEdge]
  
  nodes: [EnterpriseServerInstallation]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseServerInstallationEdge {
  
  cursor: String!
  
  node: EnterpriseServerInstallation
}
input EnterpriseServerInstallationOrder {
  
  direction: OrderDirection!
  
  field: EnterpriseServerInstallationOrderField!
}
enum EnterpriseServerInstallationOrderField {
  
  CREATED_AT
  
  CUSTOMER_NAME
  
  HOST_NAME
}
type EnterpriseServerUserAccount implements Node {
  
  createdAt: DateTime!
  
  emails(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: EnterpriseServerUserAccountEmailOrder = {field: EMAIL, direction: ASC}
  ): EnterpriseServerUserAccountEmailConnection!
  
  enterpriseServerInstallation: EnterpriseServerInstallation!
  id: ID!
  
  isSiteAdmin: Boolean!
  
  login: String!
  
  profileName: String
  
  remoteCreatedAt: DateTime!
  
  remoteUserId: Int!
  
  updatedAt: DateTime!
}
type EnterpriseServerUserAccountConnection {
  
  edges: [EnterpriseServerUserAccountEdge]
  
  nodes: [EnterpriseServerUserAccount]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseServerUserAccountEdge {
  
  cursor: String!
  
  node: EnterpriseServerUserAccount
}
type EnterpriseServerUserAccountEmail implements Node {
  
  createdAt: DateTime!
  
  email: String!
  id: ID!
  
  isPrimary: Boolean!
  
  updatedAt: DateTime!
  
  userAccount: EnterpriseServerUserAccount!
}
type EnterpriseServerUserAccountEmailConnection {
  
  edges: [EnterpriseServerUserAccountEmailEdge]
  
  nodes: [EnterpriseServerUserAccountEmail]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseServerUserAccountEmailEdge {
  
  cursor: String!
  
  node: EnterpriseServerUserAccountEmail
}
input EnterpriseServerUserAccountEmailOrder {
  
  direction: OrderDirection!
  
  field: EnterpriseServerUserAccountEmailOrderField!
}
enum EnterpriseServerUserAccountEmailOrderField {
  
  EMAIL
}
input EnterpriseServerUserAccountOrder {
  
  direction: OrderDirection!
  
  field: EnterpriseServerUserAccountOrderField!
}
enum EnterpriseServerUserAccountOrderField {
  
  LOGIN
  
  REMOTE_CREATED_AT
}
type EnterpriseServerUserAccountsUpload implements Node {
  
  createdAt: DateTime!
  
  enterprise: Enterprise!
  
  enterpriseServerInstallation: EnterpriseServerInstallation!
  id: ID!
  
  name: String!
  
  syncState: EnterpriseServerUserAccountsUploadSyncState!
  
  updatedAt: DateTime!
}
type EnterpriseServerUserAccountsUploadConnection {
  
  edges: [EnterpriseServerUserAccountsUploadEdge]
  
  nodes: [EnterpriseServerUserAccountsUpload]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseServerUserAccountsUploadEdge {
  
  cursor: String!
  
  node: EnterpriseServerUserAccountsUpload
}
input EnterpriseServerUserAccountsUploadOrder {
  
  direction: OrderDirection!
  
  field: EnterpriseServerUserAccountsUploadOrderField!
}
enum EnterpriseServerUserAccountsUploadOrderField {
  
  CREATED_AT
}
enum EnterpriseServerUserAccountsUploadSyncState {
  
  FAILURE
  
  PENDING
  
  SUCCESS
}
type EnterpriseUserAccount implements Actor & Node {
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  createdAt: DateTime!
  
  enterprise: Enterprise!
  id: ID!
  
  login: String!
  
  name: String
  
  organizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    
    query: String
    
    role: EnterpriseUserAccountMembershipRole
  ): EnterpriseOrganizationMembershipConnection!
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
  
  user: User
}
type EnterpriseUserAccountConnection {
  
  edges: [EnterpriseUserAccountEdge]
  
  nodes: [EnterpriseUserAccount]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type EnterpriseUserAccountEdge {
  
  cursor: String!
  
  node: EnterpriseUserAccount
}
enum EnterpriseUserAccountMembershipRole {
  
  MEMBER
  
  OWNER
}
enum EnterpriseUserDeployment {
  
  CLOUD
  
  SERVER
}
type ExternalIdentity implements Node {
  
  guid: String!
  id: ID!
  
  organizationInvitation: OrganizationInvitation
  
  samlIdentity: ExternalIdentitySamlAttributes
  
  scimIdentity: ExternalIdentityScimAttributes
  
  user: User
}
type ExternalIdentityConnection {
  
  edges: [ExternalIdentityEdge]
  
  nodes: [ExternalIdentity]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ExternalIdentityEdge {
  
  cursor: String!
  
  node: ExternalIdentity
}
type ExternalIdentitySamlAttributes {
  
  emails: [UserEmailMetadata!]
  
  familyName: String
  
  givenName: String
  
  groups: [String!]
  
  nameId: String
  
  username: String
}
type ExternalIdentityScimAttributes {
  
  emails: [UserEmailMetadata!]
  
  familyName: String
  
  givenName: String
  
  groups: [String!]
  
  username: String
}
enum FileViewedState {
  
  DISMISSED
  
  UNVIEWED
  
  VIEWED
}
input FollowUserInput {
  
  clientMutationId: String
  
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type FollowUserPayload {
  
  clientMutationId: String
  
  user: User
}
type FollowerConnection {
  
  edges: [UserEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type FollowingConnection {
  
  edges: [UserEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type FundingLink {
  
  platform: FundingPlatform!
  
  url: URI!
}
enum FundingPlatform {
  
  COMMUNITY_BRIDGE
  
  CUSTOM
  
  GITHUB
  
  ISSUEHUNT
  
  KO_FI
  
  LIBERAPAY
  
  OPEN_COLLECTIVE
  
  OTECHIE
  
  PATREON
  
  TIDELIFT
}
type GenericHovercardContext implements HovercardContext {
  
  message: String!
  
  octicon: String!
}
type Gist implements Node & Starrable & UniformResourceLocatable {
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): GistCommentConnection!
  
  createdAt: DateTime!
  
  description: String
  
  files(
    
    limit: Int = 10
    
    oid: GitObjectID
  ): [GistFile]
  
  forks(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: GistOrder
  ): GistConnection!
  id: ID!
  
  isFork: Boolean!
  
  isPublic: Boolean!
  
  name: String!
  
  owner: RepositoryOwner
  
  pushedAt: DateTime
  
  resourcePath: URI!
  
  stargazerCount: Int!
  
  stargazers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: StarOrder
  ): StargazerConnection!
  
  updatedAt: DateTime!
  
  url: URI!
  
  viewerHasStarred: Boolean!
}
type GistComment implements Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  editor: Actor
  
  gist: Gist!
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isMinimized: Boolean!
  
  lastEditedAt: DateTime
  
  minimizedReason: String
  
  publishedAt: DateTime
  
  updatedAt: DateTime!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanMinimize: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
}
type GistCommentConnection {
  
  edges: [GistCommentEdge]
  
  nodes: [GistComment]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type GistCommentEdge {
  
  cursor: String!
  
  node: GistComment
}
type GistConnection {
  
  edges: [GistEdge]
  
  nodes: [Gist]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type GistEdge {
  
  cursor: String!
  
  node: Gist
}
type GistFile {
  
  encodedName: String
  
  encoding: String
  
  extension: String
  
  isImage: Boolean!
  
  isTruncated: Boolean!
  
  language: Language
  
  name: String
  
  size: Int
  
  text(
    
    truncate: Int
  ): String
}
input GistOrder {
  
  direction: OrderDirection!
  
  field: GistOrderField!
}
enum GistOrderField {
  
  CREATED_AT
  
  PUSHED_AT
  
  UPDATED_AT
}
enum GistPrivacy {
  
  ALL
  
  PUBLIC
  
  SECRET
}
type GitActor {
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  date: GitTimestamp
  
  email: String
  
  name: String
  
  user: User
}
type GitActorConnection {
  
  edges: [GitActorEdge]
  
  nodes: [GitActor]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type GitActorEdge {
  
  cursor: String!
  
  node: GitActor
}
type GitHubMetadata {
  
  gitHubServicesSha: GitObjectID!
  
  gitIpAddresses: [String!]
  
  hookIpAddresses: [String!]
  
  importerIpAddresses: [String!]
  
  isPasswordAuthenticationVerifiable: Boolean!
  
  pagesIpAddresses: [String!]
}
interface GitObject {
  
  abbreviatedOid: String!
  
  commitResourcePath: URI!
  
  commitUrl: URI!
  id: ID!
  
  oid: GitObjectID!
  
  repository: Repository!
}
scalar GitObjectID
scalar GitRefname @preview(toggledBy: "update-refs-preview")
scalar GitSSHRemote
interface GitSignature {
  
  email: String!
  
  isValid: Boolean!
  
  payload: String!
  
  signature: String!
  
  signer: User
  
  state: GitSignatureState!
  
  wasSignedByGitHub: Boolean!
}
enum GitSignatureState {
  
  BAD_CERT
  
  BAD_EMAIL
  
  EXPIRED_KEY
  
  GPGVERIFY_ERROR
  
  GPGVERIFY_UNAVAILABLE
  
  INVALID
  
  MALFORMED_SIG
  
  NOT_SIGNING_KEY
  
  NO_USER
  
  OCSP_ERROR
  
  OCSP_PENDING
  
  OCSP_REVOKED
  
  UNKNOWN_KEY
  
  UNKNOWN_SIG_TYPE
  
  UNSIGNED
  
  UNVERIFIED_EMAIL
  
  VALID
}
scalar GitTimestamp
type GpgSignature implements GitSignature {
  
  email: String!
  
  isValid: Boolean!
  
  keyId: String
  
  payload: String!
  
  signature: String!
  
  signer: User
  
  state: GitSignatureState!
  
  wasSignedByGitHub: Boolean!
}
scalar HTML
type HeadRefDeletedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  headRef: Ref
  
  headRefName: String!
  id: ID!
  
  pullRequest: PullRequest!
}
type HeadRefForcePushedEvent implements Node {
  
  actor: Actor
  
  afterCommit: Commit
  
  beforeCommit: Commit
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
  
  ref: Ref
}
type HeadRefRestoredEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
}
type Hovercard {
  
  contexts: [HovercardContext!]!
}
interface HovercardContext {
  
  message: String!
  
  octicon: String!
}
enum IdentityProviderConfigurationState {
  
  CONFIGURED
  
  ENFORCED
  
  UNCONFIGURED
}
input ImportProjectInput {
  
  body: String
  
  clientMutationId: String
  
  columnImports: [ProjectColumnImport!]!
  
  name: String!
  
  ownerName: String!
  
  public: Boolean = false
}
type ImportProjectPayload {
  
  clientMutationId: String
  
  project: Project
}
input InviteEnterpriseAdminInput {
  
  clientMutationId: String
  
  email: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  invitee: String
  
  role: EnterpriseAdministratorRole
}
type InviteEnterpriseAdminPayload {
  
  clientMutationId: String
  
  invitation: EnterpriseAdministratorInvitation
}
enum IpAllowListEnabledSettingValue {
  
  DISABLED
  
  ENABLED
}
type IpAllowListEntry implements Node {
  
  allowListValue: String!
  
  createdAt: DateTime!
  id: ID!
  
  isActive: Boolean!
  
  name: String
  
  owner: IpAllowListOwner!
  
  updatedAt: DateTime!
}
type IpAllowListEntryConnection {
  
  edges: [IpAllowListEntryEdge]
  
  nodes: [IpAllowListEntry]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type IpAllowListEntryEdge {
  
  cursor: String!
  
  node: IpAllowListEntry
}
input IpAllowListEntryOrder {
  
  direction: OrderDirection!
  
  field: IpAllowListEntryOrderField!
}
enum IpAllowListEntryOrderField {
  
  ALLOW_LIST_VALUE
  
  CREATED_AT
}
union IpAllowListOwner = Enterprise | Organization
type Issue implements Assignable & Closable & Comment & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  
  activeLockReason: LockReason
  
  assignees(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyResourcePath: URI!
  
  bodyText: String!
  
  bodyUrl: URI!
  
  closed: Boolean!
  
  closedAt: DateTime
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: IssueCommentOrder
  ): IssueCommentConnection!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  editor: Actor
  
  hovercard(
    
    includeNotificationContexts: Boolean = true
  ): Hovercard!
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isReadByViewer: Boolean
  
  labels(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
  
  lastEditedAt: DateTime
  
  locked: Boolean!
  
  milestone: Milestone
  
  number: Int!
  
  participants(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
  
  projectCards(
    
    after: String
    
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    
    before: String
    
    first: Int
    
    last: Int
  ): ProjectCardConnection!
  
  publishedAt: DateTime
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  state: IssueState!
  
  timeline(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    since: DateTime
  ): IssueTimelineConnection! @deprecated(reason: "`timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.")
  
  timelineItems(
    
    after: String
    
    before: String
    
    first: Int
    
    itemTypes: [IssueTimelineItemsItemType!]
    
    last: Int
    
    since: DateTime
    
    skip: Int
  ): IssueTimelineItemsConnection!
  
  title: String!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanReact: Boolean!
  
  viewerCanSubscribe: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
  
  viewerSubscription: SubscriptionState
}
type IssueComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isMinimized: Boolean!
  
  issue: Issue!
  
  lastEditedAt: DateTime
  
  minimizedReason: String
  
  publishedAt: DateTime
  
  pullRequest: PullRequest
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanMinimize: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
}
type IssueCommentConnection {
  
  edges: [IssueCommentEdge]
  
  nodes: [IssueComment]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type IssueCommentEdge {
  
  cursor: String!
  
  node: IssueComment
}
input IssueCommentOrder {
  
  direction: OrderDirection!
  
  field: IssueCommentOrderField!
}
enum IssueCommentOrderField {
  
  UPDATED_AT
}
type IssueConnection {
  
  edges: [IssueEdge]
  
  nodes: [Issue]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type IssueContributionsByRepository {
  
  contributions(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedIssueContributionConnection!
  
  repository: Repository!
}
type IssueEdge {
  
  cursor: String!
  
  node: Issue
}
input IssueFilters {
  
  assignee: String
  
  createdBy: String
  
  labels: [String!]
  
  mentioned: String
  
  milestone: String
  
  since: DateTime
  
  states: [IssueState!]
  
  viewerSubscribed: Boolean = false
}
union IssueOrPullRequest = Issue | PullRequest
input IssueOrder {
  
  direction: OrderDirection!
  
  field: IssueOrderField!
}
enum IssueOrderField {
  
  COMMENTS
  
  CREATED_AT
  
  UPDATED_AT
}
enum IssueState {
  
  CLOSED
  
  OPEN
}
type IssueTemplate {
  
  about: String
  
  body: String
  
  name: String!
  
  title: String
}
type IssueTimelineConnection {
  
  edges: [IssueTimelineItemEdge]
  
  nodes: [IssueTimelineItem]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
union IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent
type IssueTimelineItemEdge {
  
  cursor: String!
  
  node: IssueTimelineItem
}
union IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent
type IssueTimelineItemsConnection {
  
  edges: [IssueTimelineItemsEdge]
  
  filteredCount: Int!
  
  nodes: [IssueTimelineItems]
  
  pageCount: Int!
  
  pageInfo: PageInfo!
  
  totalCount: Int!
  
  updatedAt: DateTime!
}
type IssueTimelineItemsEdge {
  
  cursor: String!
  
  node: IssueTimelineItems
}
enum IssueTimelineItemsItemType {
  
  ADDED_TO_PROJECT_EVENT
  
  ASSIGNED_EVENT
  
  CLOSED_EVENT
  
  COMMENT_DELETED_EVENT
  
  CONNECTED_EVENT
  
  CONVERTED_NOTE_TO_ISSUE_EVENT
  
  CROSS_REFERENCED_EVENT
  
  DEMILESTONED_EVENT
  
  DISCONNECTED_EVENT
  
  ISSUE_COMMENT
  
  LABELED_EVENT
  
  LOCKED_EVENT
  
  MARKED_AS_DUPLICATE_EVENT
  
  MENTIONED_EVENT
  
  MILESTONED_EVENT
  
  MOVED_COLUMNS_IN_PROJECT_EVENT
  
  PINNED_EVENT
  
  REFERENCED_EVENT
  
  REMOVED_FROM_PROJECT_EVENT
  
  RENAMED_TITLE_EVENT
  
  REOPENED_EVENT
  
  SUBSCRIBED_EVENT
  
  TRANSFERRED_EVENT
  
  UNASSIGNED_EVENT
  
  UNLABELED_EVENT
  
  UNLOCKED_EVENT
  
  UNMARKED_AS_DUPLICATE_EVENT
  
  UNPINNED_EVENT
  
  UNSUBSCRIBED_EVENT
  
  USER_BLOCKED_EVENT
}
type JoinedGitHubContribution implements Contribution {
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type Label implements Node {
  
  color: String!
  
  createdAt: DateTime
  
  description: String
  id: ID!
  
  isDefault: Boolean!
  
  issues(
    
    after: String
    
    before: String
    
    filterBy: IssueFilters
    
    first: Int
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [IssueState!]
  ): IssueConnection!
  
  name: String!
  
  pullRequests(
    
    after: String
    
    baseRefName: String
    
    before: String
    
    first: Int
    
    headRefName: String
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [PullRequestState!]
  ): PullRequestConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  updatedAt: DateTime
  
  url: URI!
}
type LabelConnection {
  
  edges: [LabelEdge]
  
  nodes: [Label]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type LabelEdge {
  
  cursor: String!
  
  node: Label
}
input LabelOrder {
  
  direction: OrderDirection!
  
  field: LabelOrderField!
}
enum LabelOrderField {
  
  CREATED_AT
  
  NAME
}
interface Labelable {
  
  labels(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
}
type LabeledEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  label: Label!
  
  labelable: Labelable!
}
type Language implements Node {
  
  color: String
  id: ID!
  
  name: String!
}
type LanguageConnection {
  
  edges: [LanguageEdge]
  
  nodes: [Language]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
  
  totalSize: Int!
}
type LanguageEdge {
  cursor: String!
  node: Language!
  
  size: Int!
}
input LanguageOrder {
  
  direction: OrderDirection!
  
  field: LanguageOrderField!
}
enum LanguageOrderField {
  
  SIZE
}
type License implements Node {
  
  body: String!
  
  conditions: [LicenseRule]!
  
  description: String
  
  featured: Boolean!
  
  hidden: Boolean!
  id: ID!
  
  implementation: String
  
  key: String!
  
  limitations: [LicenseRule]!
  
  name: String!
  
  nickname: String
  
  permissions: [LicenseRule]!
  
  pseudoLicense: Boolean!
  
  spdxId: String
  
  url: URI
}
type LicenseRule {
  
  description: String!
  
  key: String!
  
  label: String!
}
input LinkRepositoryToProjectInput {
  
  clientMutationId: String
  
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type LinkRepositoryToProjectPayload {
  
  clientMutationId: String
  
  project: Project
  
  repository: Repository
}
input LockLockableInput {
  
  clientMutationId: String
  
  lockReason: LockReason
  
  lockableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Lockable")
}
type LockLockablePayload {
  
  actor: Actor
  
  clientMutationId: String
  
  lockedRecord: Lockable
}
enum LockReason {
  
  OFF_TOPIC
  
  RESOLVED
  
  SPAM
  
  TOO_HEATED
}
interface Lockable {
  
  activeLockReason: LockReason
  
  locked: Boolean!
}
type LockedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  lockReason: LockReason
  
  lockable: Lockable!
}
type Mannequin implements Actor & Node & UniformResourceLocatable {
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  createdAt: DateTime!
  
  databaseId: Int
  
  email: String
  id: ID!
  
  login: String!
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
}
input MarkFileAsViewedInput {
  
  clientMutationId: String
  
  path: String!
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type MarkFileAsViewedPayload {
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
input MarkPullRequestReadyForReviewInput {
  
  clientMutationId: String
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type MarkPullRequestReadyForReviewPayload {
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
type MarkedAsDuplicateEvent implements Node {
  
  actor: Actor
  
  canonical: IssueOrPullRequest
  
  createdAt: DateTime!
  
  duplicate: IssueOrPullRequest
  id: ID!
  
  isCrossRepository: Boolean!
}
type MarketplaceCategory implements Node {
  
  description: String
  
  howItWorks: String
  id: ID!
  
  name: String!
  
  primaryListingCount: Int!
  
  resourcePath: URI!
  
  secondaryListingCount: Int!
  
  slug: String!
  
  url: URI!
}
type MarketplaceListing implements Node {
  
  app: App
  
  companyUrl: URI
  
  configurationResourcePath: URI!
  
  configurationUrl: URI!
  
  documentationUrl: URI
  
  extendedDescription: String
  
  extendedDescriptionHTML: HTML!
  
  fullDescription: String!
  
  fullDescriptionHTML: HTML!
  
  hasPublishedFreeTrialPlans: Boolean!
  
  hasTermsOfService: Boolean!
  
  hasVerifiedOwner: Boolean!
  
  howItWorks: String
  
  howItWorksHTML: HTML!
  id: ID!
  
  installationUrl: URI
  
  installedForViewer: Boolean!
  
  isArchived: Boolean!
  
  isDraft: Boolean!
  
  isPaid: Boolean!
  
  isPublic: Boolean!
  
  isRejected: Boolean!
  
  isUnverified: Boolean!
  
  isUnverifiedPending: Boolean!
  
  isVerificationPendingFromDraft: Boolean!
  
  isVerificationPendingFromUnverified: Boolean!
  
  isVerified: Boolean!
  
  logoBackgroundColor: String!
  
  logoUrl(
    
    size: Int = 400
  ): URI
  
  name: String!
  
  normalizedShortDescription: String!
  
  pricingUrl: URI
  
  primaryCategory: MarketplaceCategory!
  
  privacyPolicyUrl: URI!
  
  resourcePath: URI!
  
  screenshotUrls: [String]!
  
  secondaryCategory: MarketplaceCategory
  
  shortDescription: String!
  
  slug: String!
  
  statusUrl: URI
  
  supportEmail: String
  
  supportUrl: URI!
  
  termsOfServiceUrl: URI
  
  url: URI!
  
  viewerCanAddPlans: Boolean!
  
  viewerCanApprove: Boolean!
  
  viewerCanDelist: Boolean!
  
  viewerCanEdit: Boolean!
  
  viewerCanEditCategories: Boolean!
  
  viewerCanEditPlans: Boolean!
  
  viewerCanRedraft: Boolean!
  
  viewerCanReject: Boolean!
  
  viewerCanRequestApproval: Boolean!
  
  viewerHasPurchased: Boolean!
  
  viewerHasPurchasedForAllOrganizations: Boolean!
  
  viewerIsListingAdmin: Boolean!
}
type MarketplaceListingConnection {
  
  edges: [MarketplaceListingEdge]
  
  nodes: [MarketplaceListing]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type MarketplaceListingEdge {
  
  cursor: String!
  
  node: MarketplaceListing
}
interface MemberStatusable {
  
  memberStatuses(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
}
type MembersCanDeleteReposClearAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type MembersCanDeleteReposDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type MembersCanDeleteReposEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type MentionedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
}
input MergeBranchInput {
  
  authorEmail: String
  
  base: String!
  
  clientMutationId: String
  
  commitMessage: String
  
  head: String!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type MergeBranchPayload {
  
  clientMutationId: String
  
  mergeCommit: Commit
}
input MergePullRequestInput {
  
  authorEmail: String
  
  clientMutationId: String
  
  commitBody: String
  
  commitHeadline: String
  
  expectedHeadOid: GitObjectID
  
  mergeMethod: PullRequestMergeMethod = MERGE
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type MergePullRequestPayload {
  
  actor: Actor
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
enum MergeStateStatus {
  
  BEHIND
  
  BLOCKED
  
  CLEAN
  
  DIRTY
  
  DRAFT @deprecated(reason: "DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.")
  
  HAS_HOOKS
  
  UNKNOWN
  
  UNSTABLE
}
enum MergeableState {
  
  CONFLICTING
  
  MERGEABLE
  
  UNKNOWN
}
type MergedEvent implements Node & UniformResourceLocatable {
  
  actor: Actor
  
  commit: Commit
  
  createdAt: DateTime!
  id: ID!
  
  mergeRef: Ref
  
  mergeRefName: String!
  
  pullRequest: PullRequest!
  
  resourcePath: URI!
  
  url: URI!
}
type Milestone implements Closable & Node & UniformResourceLocatable {
  
  closed: Boolean!
  
  closedAt: DateTime
  
  createdAt: DateTime!
  
  creator: Actor
  
  description: String
  
  dueOn: DateTime
  id: ID!
  
  issues(
    
    after: String
    
    before: String
    
    filterBy: IssueFilters
    
    first: Int
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [IssueState!]
  ): IssueConnection!
  
  number: Int!
  
  progressPercentage: Float!
  
  pullRequests(
    
    after: String
    
    baseRefName: String
    
    before: String
    
    first: Int
    
    headRefName: String
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [PullRequestState!]
  ): PullRequestConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  state: MilestoneState!
  
  title: String!
  
  updatedAt: DateTime!
  
  url: URI!
}
type MilestoneConnection {
  
  edges: [MilestoneEdge]
  
  nodes: [Milestone]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type MilestoneEdge {
  
  cursor: String!
  
  node: Milestone
}
union MilestoneItem = Issue | PullRequest
input MilestoneOrder {
  
  direction: OrderDirection!
  
  field: MilestoneOrderField!
}
enum MilestoneOrderField {
  
  CREATED_AT
  
  DUE_DATE
  
  NUMBER
  
  UPDATED_AT
}
enum MilestoneState {
  
  CLOSED
  
  OPEN
}
type MilestonedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  milestoneTitle: String!
  
  subject: MilestoneItem!
}
interface Minimizable {
  
  isMinimized: Boolean!
  
  minimizedReason: String
  
  viewerCanMinimize: Boolean!
}
input MinimizeCommentInput {
  
  classifier: ReportedContentClassifiers!
  
  clientMutationId: String
  
  subjectId: ID! @possibleTypes(concreteTypes: ["CommitComment", "GistComment", "IssueComment", "PullRequestReviewComment"], abstractType: "Minimizable")
}
type MinimizeCommentPayload {
  
  clientMutationId: String
  
  minimizedComment: Minimizable
}
input MoveProjectCardInput {
  
  afterCardId: ID @possibleTypes(concreteTypes: ["ProjectCard"])
  
  cardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
  
  clientMutationId: String
  
  columnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type MoveProjectCardPayload {
  
  cardEdge: ProjectCardEdge
  
  clientMutationId: String
}
input MoveProjectColumnInput {
  
  afterColumnId: ID @possibleTypes(concreteTypes: ["ProjectColumn"])
  
  clientMutationId: String
  
  columnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type MoveProjectColumnPayload {
  
  clientMutationId: String
  
  columnEdge: ProjectColumnEdge
}
type MovedColumnsInProjectEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  previousProjectColumnName: String! @preview(toggledBy: "starfox-preview")
  
  project: Project @preview(toggledBy: "starfox-preview")
  
  projectCard: ProjectCard @preview(toggledBy: "starfox-preview")
  
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
type Mutation {
  
  acceptEnterpriseAdministratorInvitation(input: AcceptEnterpriseAdministratorInvitationInput!): AcceptEnterpriseAdministratorInvitationPayload
  
  acceptTopicSuggestion(input: AcceptTopicSuggestionInput!): AcceptTopicSuggestionPayload
  
  addAssigneesToAssignable(input: AddAssigneesToAssignableInput!): AddAssigneesToAssignablePayload
  
  addComment(input: AddCommentInput!): AddCommentPayload
  
  addLabelsToLabelable(input: AddLabelsToLabelableInput!): AddLabelsToLabelablePayload
  
  addProjectCard(input: AddProjectCardInput!): AddProjectCardPayload
  
  addProjectColumn(input: AddProjectColumnInput!): AddProjectColumnPayload
  
  addPullRequestReview(input: AddPullRequestReviewInput!): AddPullRequestReviewPayload
  
  addPullRequestReviewComment(input: AddPullRequestReviewCommentInput!): AddPullRequestReviewCommentPayload
  
  addPullRequestReviewThread(input: AddPullRequestReviewThreadInput!): AddPullRequestReviewThreadPayload
  
  addReaction(input: AddReactionInput!): AddReactionPayload
  
  addStar(input: AddStarInput!): AddStarPayload
  
  archiveRepository(input: ArchiveRepositoryInput!): ArchiveRepositoryPayload
  
  cancelEnterpriseAdminInvitation(input: CancelEnterpriseAdminInvitationInput!): CancelEnterpriseAdminInvitationPayload
  
  changeUserStatus(input: ChangeUserStatusInput!): ChangeUserStatusPayload
  
  clearLabelsFromLabelable(input: ClearLabelsFromLabelableInput!): ClearLabelsFromLabelablePayload
  
  cloneProject(input: CloneProjectInput!): CloneProjectPayload
  
  cloneTemplateRepository(input: CloneTemplateRepositoryInput!): CloneTemplateRepositoryPayload
  
  closeIssue(input: CloseIssueInput!): CloseIssuePayload
  
  closePullRequest(input: ClosePullRequestInput!): ClosePullRequestPayload
  
  convertProjectCardNoteToIssue(input: ConvertProjectCardNoteToIssueInput!): ConvertProjectCardNoteToIssuePayload
  
  createBranchProtectionRule(input: CreateBranchProtectionRuleInput!): CreateBranchProtectionRulePayload
  
  createCheckRun(input: CreateCheckRunInput!): CreateCheckRunPayload
  
  createCheckSuite(input: CreateCheckSuiteInput!): CreateCheckSuitePayload
  
  createContentAttachment(input: CreateContentAttachmentInput!): CreateContentAttachmentPayload @preview(toggledBy: "corsair-preview")
  
  createDeployment(input: CreateDeploymentInput!): CreateDeploymentPayload @preview(toggledBy: "flash-preview")
  
  createDeploymentStatus(input: CreateDeploymentStatusInput!): CreateDeploymentStatusPayload @preview(toggledBy: "flash-preview")
  
  createEnterpriseOrganization(input: CreateEnterpriseOrganizationInput!): CreateEnterpriseOrganizationPayload
  
  createIpAllowListEntry(input: CreateIpAllowListEntryInput!): CreateIpAllowListEntryPayload
  
  createIssue(input: CreateIssueInput!): CreateIssuePayload
  
  createLabel(input: CreateLabelInput!): CreateLabelPayload @preview(toggledBy: "bane-preview")
  
  createProject(input: CreateProjectInput!): CreateProjectPayload
  
  createPullRequest(input: CreatePullRequestInput!): CreatePullRequestPayload
  
  createRef(input: CreateRefInput!): CreateRefPayload
  
  createRepository(input: CreateRepositoryInput!): CreateRepositoryPayload
  
  createTeamDiscussion(input: CreateTeamDiscussionInput!): CreateTeamDiscussionPayload
  
  createTeamDiscussionComment(input: CreateTeamDiscussionCommentInput!): CreateTeamDiscussionCommentPayload
  
  declineTopicSuggestion(input: DeclineTopicSuggestionInput!): DeclineTopicSuggestionPayload
  
  deleteBranchProtectionRule(input: DeleteBranchProtectionRuleInput!): DeleteBranchProtectionRulePayload
  
  deleteDeployment(input: DeleteDeploymentInput!): DeleteDeploymentPayload
  
  deleteIpAllowListEntry(input: DeleteIpAllowListEntryInput!): DeleteIpAllowListEntryPayload
  
  deleteIssue(input: DeleteIssueInput!): DeleteIssuePayload
  
  deleteIssueComment(input: DeleteIssueCommentInput!): DeleteIssueCommentPayload
  
  deleteLabel(input: DeleteLabelInput!): DeleteLabelPayload @preview(toggledBy: "bane-preview")
  
  deletePackageVersion(input: DeletePackageVersionInput!): DeletePackageVersionPayload @preview(toggledBy: "package-deletes-preview")
  
  deleteProject(input: DeleteProjectInput!): DeleteProjectPayload
  
  deleteProjectCard(input: DeleteProjectCardInput!): DeleteProjectCardPayload
  
  deleteProjectColumn(input: DeleteProjectColumnInput!): DeleteProjectColumnPayload
  
  deletePullRequestReview(input: DeletePullRequestReviewInput!): DeletePullRequestReviewPayload
  
  deletePullRequestReviewComment(input: DeletePullRequestReviewCommentInput!): DeletePullRequestReviewCommentPayload
  
  deleteRef(input: DeleteRefInput!): DeleteRefPayload
  
  deleteTeamDiscussion(input: DeleteTeamDiscussionInput!): DeleteTeamDiscussionPayload
  
  deleteTeamDiscussionComment(input: DeleteTeamDiscussionCommentInput!): DeleteTeamDiscussionCommentPayload
  
  dismissPullRequestReview(input: DismissPullRequestReviewInput!): DismissPullRequestReviewPayload
  
  followUser(input: FollowUserInput!): FollowUserPayload
  
  importProject(input: ImportProjectInput!): ImportProjectPayload @preview(toggledBy: "slothette-preview")
  
  inviteEnterpriseAdmin(input: InviteEnterpriseAdminInput!): InviteEnterpriseAdminPayload
  
  linkRepositoryToProject(input: LinkRepositoryToProjectInput!): LinkRepositoryToProjectPayload
  
  lockLockable(input: LockLockableInput!): LockLockablePayload
  
  markFileAsViewed(input: MarkFileAsViewedInput!): MarkFileAsViewedPayload
  
  markPullRequestReadyForReview(input: MarkPullRequestReadyForReviewInput!): MarkPullRequestReadyForReviewPayload
  
  mergeBranch(input: MergeBranchInput!): MergeBranchPayload
  
  mergePullRequest(input: MergePullRequestInput!): MergePullRequestPayload
  
  minimizeComment(input: MinimizeCommentInput!): MinimizeCommentPayload
  
  moveProjectCard(input: MoveProjectCardInput!): MoveProjectCardPayload
  
  moveProjectColumn(input: MoveProjectColumnInput!): MoveProjectColumnPayload
  
  pinIssue(input: PinIssueInput!): PinIssuePayload @preview(toggledBy: "elektra-preview")
  
  regenerateEnterpriseIdentityProviderRecoveryCodes(input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput!): RegenerateEnterpriseIdentityProviderRecoveryCodesPayload
  
  removeAssigneesFromAssignable(input: RemoveAssigneesFromAssignableInput!): RemoveAssigneesFromAssignablePayload
  
  removeEnterpriseAdmin(input: RemoveEnterpriseAdminInput!): RemoveEnterpriseAdminPayload
  
  removeEnterpriseIdentityProvider(input: RemoveEnterpriseIdentityProviderInput!): RemoveEnterpriseIdentityProviderPayload
  
  removeEnterpriseOrganization(input: RemoveEnterpriseOrganizationInput!): RemoveEnterpriseOrganizationPayload
  
  removeLabelsFromLabelable(input: RemoveLabelsFromLabelableInput!): RemoveLabelsFromLabelablePayload
  
  removeOutsideCollaborator(input: RemoveOutsideCollaboratorInput!): RemoveOutsideCollaboratorPayload
  
  removeReaction(input: RemoveReactionInput!): RemoveReactionPayload
  
  removeStar(input: RemoveStarInput!): RemoveStarPayload
  
  reopenIssue(input: ReopenIssueInput!): ReopenIssuePayload
  
  reopenPullRequest(input: ReopenPullRequestInput!): ReopenPullRequestPayload
  
  requestReviews(input: RequestReviewsInput!): RequestReviewsPayload
  
  rerequestCheckSuite(input: RerequestCheckSuiteInput!): RerequestCheckSuitePayload
  
  resolveReviewThread(input: ResolveReviewThreadInput!): ResolveReviewThreadPayload
  
  setEnterpriseIdentityProvider(input: SetEnterpriseIdentityProviderInput!): SetEnterpriseIdentityProviderPayload
  
  setOrganizationInteractionLimit(input: SetOrganizationInteractionLimitInput!): SetOrganizationInteractionLimitPayload
  
  setRepositoryInteractionLimit(input: SetRepositoryInteractionLimitInput!): SetRepositoryInteractionLimitPayload
  
  setUserInteractionLimit(input: SetUserInteractionLimitInput!): SetUserInteractionLimitPayload
  
  submitPullRequestReview(input: SubmitPullRequestReviewInput!): SubmitPullRequestReviewPayload
  
  transferIssue(input: TransferIssueInput!): TransferIssuePayload
  
  unarchiveRepository(input: UnarchiveRepositoryInput!): UnarchiveRepositoryPayload
  
  unfollowUser(input: UnfollowUserInput!): UnfollowUserPayload
  
  unlinkRepositoryFromProject(input: UnlinkRepositoryFromProjectInput!): UnlinkRepositoryFromProjectPayload
  
  unlockLockable(input: UnlockLockableInput!): UnlockLockablePayload
  
  unmarkFileAsViewed(input: UnmarkFileAsViewedInput!): UnmarkFileAsViewedPayload
  
  unmarkIssueAsDuplicate(input: UnmarkIssueAsDuplicateInput!): UnmarkIssueAsDuplicatePayload
  
  unminimizeComment(input: UnminimizeCommentInput!): UnminimizeCommentPayload
  
  unpinIssue(input: UnpinIssueInput!): UnpinIssuePayload @preview(toggledBy: "elektra-preview")
  
  unresolveReviewThread(input: UnresolveReviewThreadInput!): UnresolveReviewThreadPayload
  
  updateBranchProtectionRule(input: UpdateBranchProtectionRuleInput!): UpdateBranchProtectionRulePayload
  
  updateCheckRun(input: UpdateCheckRunInput!): UpdateCheckRunPayload
  
  updateCheckSuitePreferences(input: UpdateCheckSuitePreferencesInput!): UpdateCheckSuitePreferencesPayload
  
  updateEnterpriseAdministratorRole(input: UpdateEnterpriseAdministratorRoleInput!): UpdateEnterpriseAdministratorRolePayload
  
  updateEnterpriseAllowPrivateRepositoryForkingSetting(input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput!): UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload
  
  updateEnterpriseDefaultRepositoryPermissionSetting(input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput!): UpdateEnterpriseDefaultRepositoryPermissionSettingPayload
  
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting(input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput!): UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload
  
  updateEnterpriseMembersCanCreateRepositoriesSetting(input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput!): UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload
  
  updateEnterpriseMembersCanDeleteIssuesSetting(input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput!): UpdateEnterpriseMembersCanDeleteIssuesSettingPayload
  
  updateEnterpriseMembersCanDeleteRepositoriesSetting(input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput!): UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload
  
  updateEnterpriseMembersCanInviteCollaboratorsSetting(input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput!): UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload
  
  updateEnterpriseMembersCanMakePurchasesSetting(input: UpdateEnterpriseMembersCanMakePurchasesSettingInput!): UpdateEnterpriseMembersCanMakePurchasesSettingPayload
  
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting(input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput!): UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload
  
  updateEnterpriseMembersCanViewDependencyInsightsSetting(input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput!): UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload
  
  updateEnterpriseOrganizationProjectsSetting(input: UpdateEnterpriseOrganizationProjectsSettingInput!): UpdateEnterpriseOrganizationProjectsSettingPayload
  
  updateEnterpriseProfile(input: UpdateEnterpriseProfileInput!): UpdateEnterpriseProfilePayload
  
  updateEnterpriseRepositoryProjectsSetting(input: UpdateEnterpriseRepositoryProjectsSettingInput!): UpdateEnterpriseRepositoryProjectsSettingPayload
  
  updateEnterpriseTeamDiscussionsSetting(input: UpdateEnterpriseTeamDiscussionsSettingInput!): UpdateEnterpriseTeamDiscussionsSettingPayload
  
  updateEnterpriseTwoFactorAuthenticationRequiredSetting(input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput!): UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload
  
  updateIpAllowListEnabledSetting(input: UpdateIpAllowListEnabledSettingInput!): UpdateIpAllowListEnabledSettingPayload
  
  updateIpAllowListEntry(input: UpdateIpAllowListEntryInput!): UpdateIpAllowListEntryPayload
  
  updateIssue(input: UpdateIssueInput!): UpdateIssuePayload
  
  updateIssueComment(input: UpdateIssueCommentInput!): UpdateIssueCommentPayload
  
  updateLabel(input: UpdateLabelInput!): UpdateLabelPayload @preview(toggledBy: "bane-preview")
  
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  
  updateProjectCard(input: UpdateProjectCardInput!): UpdateProjectCardPayload
  
  updateProjectColumn(input: UpdateProjectColumnInput!): UpdateProjectColumnPayload
  
  updatePullRequest(input: UpdatePullRequestInput!): UpdatePullRequestPayload
  
  updatePullRequestReview(input: UpdatePullRequestReviewInput!): UpdatePullRequestReviewPayload
  
  updatePullRequestReviewComment(input: UpdatePullRequestReviewCommentInput!): UpdatePullRequestReviewCommentPayload
  
  updateRef(input: UpdateRefInput!): UpdateRefPayload
  
  updateRefs(input: UpdateRefsInput!): UpdateRefsPayload @preview(toggledBy: "update-refs-preview")
  
  updateRepository(input: UpdateRepositoryInput!): UpdateRepositoryPayload
  
  updateSubscription(input: UpdateSubscriptionInput!): UpdateSubscriptionPayload
  
  updateTeamDiscussion(input: UpdateTeamDiscussionInput!): UpdateTeamDiscussionPayload
  
  updateTeamDiscussionComment(input: UpdateTeamDiscussionCommentInput!): UpdateTeamDiscussionCommentPayload
  
  updateTeamReviewAssignment(input: UpdateTeamReviewAssignmentInput!): UpdateTeamReviewAssignmentPayload @preview(toggledBy: "stone-crop-preview")
  
  updateTopics(input: UpdateTopicsInput!): UpdateTopicsPayload
}
interface Node {
  
  id: ID!
}
interface OauthApplicationAuditEntryData {
  
  oauthApplicationName: String
  
  oauthApplicationResourcePath: URI
  
  oauthApplicationUrl: URI
}
type OauthApplicationCreateAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  applicationUrl: URI
  
  callbackUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  oauthApplicationName: String
  
  oauthApplicationResourcePath: URI
  
  oauthApplicationUrl: URI
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  rateLimit: Int
  
  state: OauthApplicationCreateAuditEntryState
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OauthApplicationCreateAuditEntryState {
  
  ACTIVE
  
  PENDING_DELETION
  
  SUSPENDED
}
enum OperationType {
  
  ACCESS
  
  AUTHENTICATION
  
  CREATE
  
  MODIFY
  
  REMOVE
  
  RESTORE
  
  TRANSFER
}
enum OrderDirection {
  
  ASC
  
  DESC
}
type OrgAddBillingManagerAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  invitationEmail: String
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  permission: OrgAddMemberAuditEntryPermission
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgAddMemberAuditEntryPermission {
  
  ADMIN
  
  READ
}
type OrgBlockUserAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  blockedUser: User
  
  blockedUserName: String
  
  blockedUserResourcePath: URI
  
  blockedUserUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgConfigDisableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgConfigEnableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgCreateAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  billingPlan: OrgCreateAuditEntryBillingPlan
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgCreateAuditEntryBillingPlan {
  
  BUSINESS
  
  BUSINESS_PLUS
  
  FREE
  
  TIERED_PER_SEAT
  
  UNLIMITED
}
type OrgDisableOauthAppRestrictionsAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgDisableSamlAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  digestMethodUrl: URI
  id: ID!
  
  issuerUrl: URI
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  signatureMethodUrl: URI
  
  singleSignOnUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgDisableTwoFactorRequirementAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgEnableOauthAppRestrictionsAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgEnableSamlAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  digestMethodUrl: URI
  id: ID!
  
  issuerUrl: URI
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  signatureMethodUrl: URI
  
  singleSignOnUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgEnableTwoFactorRequirementAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgInviteMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  email: String
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationInvitation: OrganizationInvitation
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgInviteToBusinessAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgOauthAppAccessApprovedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  oauthApplicationName: String
  
  oauthApplicationResourcePath: URI
  
  oauthApplicationUrl: URI
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgOauthAppAccessDeniedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  oauthApplicationName: String
  
  oauthApplicationResourcePath: URI
  
  oauthApplicationUrl: URI
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgOauthAppAccessRequestedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  oauthApplicationName: String
  
  oauthApplicationResourcePath: URI
  
  oauthApplicationUrl: URI
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgRemoveBillingManagerAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  reason: OrgRemoveBillingManagerAuditEntryReason
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgRemoveBillingManagerAuditEntryReason {
  
  SAML_EXTERNAL_IDENTITY_MISSING
  
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY
  
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
}
type OrgRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  membershipTypes: [OrgRemoveMemberAuditEntryMembershipType!]
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  reason: OrgRemoveMemberAuditEntryReason
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgRemoveMemberAuditEntryMembershipType {
  
  ADMIN
  
  BILLING_MANAGER
  
  DIRECT_MEMBER
  
  OUTSIDE_COLLABORATOR
  
  UNAFFILIATED
}
enum OrgRemoveMemberAuditEntryReason {
  
  SAML_EXTERNAL_IDENTITY_MISSING
  
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY
  
  TWO_FACTOR_ACCOUNT_RECOVERY
  
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
  
  USER_ACCOUNT_DELETED
}
type OrgRemoveOutsideCollaboratorAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  membershipTypes: [OrgRemoveOutsideCollaboratorAuditEntryMembershipType!]
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  reason: OrgRemoveOutsideCollaboratorAuditEntryReason
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  
  BILLING_MANAGER
  
  OUTSIDE_COLLABORATOR
  
  UNAFFILIATED
}
enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  
  SAML_EXTERNAL_IDENTITY_MISSING
  
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
}
type OrgRestoreMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  restoredCustomEmailRoutingsCount: Int
  
  restoredIssueAssignmentsCount: Int
  
  restoredMemberships: [OrgRestoreMemberAuditEntryMembership!]
  
  restoredMembershipsCount: Int
  
  restoredRepositoriesCount: Int
  
  restoredRepositoryStarsCount: Int
  
  restoredRepositoryWatchesCount: Int
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
union OrgRestoreMemberAuditEntryMembership = OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData
type OrgRestoreMemberMembershipOrganizationAuditEntryData implements OrganizationAuditEntryData {
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
}
type OrgRestoreMemberMembershipRepositoryAuditEntryData implements RepositoryAuditEntryData {
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
}
type OrgRestoreMemberMembershipTeamAuditEntryData implements TeamAuditEntryData {
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
}
type OrgUnblockUserAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  blockedUser: User
  
  blockedUserName: String
  
  blockedUserResourcePath: URI
  
  blockedUserUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type OrgUpdateDefaultRepositoryPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  permission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
  
  permissionWas: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  
  ADMIN
  
  NONE
  
  READ
  
  WRITE
}
type OrgUpdateMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  permission: OrgUpdateMemberAuditEntryPermission
  
  permissionWas: OrgUpdateMemberAuditEntryPermission
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum OrgUpdateMemberAuditEntryPermission {
  
  ADMIN
  
  READ
}
type OrgUpdateMemberRepositoryCreationPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  canCreateRepositories: Boolean
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
}
enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  
  ALL
  
  INTERNAL
  
  NONE
  
  PRIVATE
  
  PRIVATE_INTERNAL
  
  PUBLIC
  
  PUBLIC_INTERNAL
  
  PUBLIC_PRIVATE
}
type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  canInviteOutsideCollaboratorsToRepositories: Boolean
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type Organization implements Actor & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  
  anyPinnableItems(
    
    type: PinnableItemType
  ): Boolean!
  
  auditLog(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: AuditLogOrder = {field: CREATED_AT, direction: DESC}
    
    query: String
  ): OrganizationAuditEntryConnection!
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  createdAt: DateTime!
  
  databaseId: Int
  
  description: String
  
  descriptionHTML: String
  
  email: String
  
  hasSponsorsListing: Boolean!
  id: ID!
  
  interactionAbility: RepositoryInteractionAbility
  
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue!
  
  ipAllowListEntries(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: IpAllowListEntryOrder = {field: ALLOW_LIST_VALUE, direction: ASC}
  ): IpAllowListEntryConnection!
  
  isSponsoringViewer: Boolean!
  
  isVerified: Boolean!
  
  itemShowcase: ProfileItemShowcase!
  
  location: String
  
  login: String!
  
  memberStatuses(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
  
  membersWithRole(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): OrganizationMemberConnection!
  
  name: String
  
  newTeamResourcePath: URI!
  
  newTeamUrl: URI!
  
  organizationBillingEmail: String
  
  packages(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    names: [String]
    
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    
    packageType: PackageType
    
    repositoryId: ID
  ): PackageConnection!
  
  pendingMembers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
  
  pinnableItems(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  
  pinnedItems(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  
  pinnedItemsRemaining: Int!
  
  project(
    
    number: Int!
  ): Project
  
  projects(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ProjectOrder
    
    search: String
    
    states: [ProjectState!]
  ): ProjectConnection!
  
  projectsResourcePath: URI!
  
  projectsUrl: URI!
  
  repositories(
    
    affiliations: [RepositoryAffiliation]
    
    after: String
    
    before: String
    
    first: Int
    
    isFork: Boolean
    
    isLocked: Boolean
    
    last: Int
    
    orderBy: RepositoryOrder
    
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  
  repository(
    
    name: String!
  ): Repository
  
  requiresTwoFactorAuthentication: Boolean
  
  resourcePath: URI!
  
  samlIdentityProvider: OrganizationIdentityProvider
  
  sponsorsListing: SponsorsListing
  
  sponsorshipsAsMaintainer(
    
    after: String
    
    before: String
    
    first: Int
    
    includePrivate: Boolean = false
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  
  sponsorshipsAsSponsor(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  
  team(
    
    slug: String!
  ): Team
  
  teams(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    ldapMapped: Boolean
    
    orderBy: TeamOrder
    
    privacy: TeamPrivacy
    
    query: String
    
    role: TeamRole
    
    rootTeamsOnly: Boolean = false
    
    userLogins: [String!]
  ): TeamConnection!
  
  teamsResourcePath: URI!
  
  teamsUrl: URI!
  
  twitterUsername: String
  
  updatedAt: DateTime!
  
  url: URI!
  
  viewerCanAdminister: Boolean!
  
  viewerCanChangePinnedItems: Boolean!
  
  viewerCanCreateProjects: Boolean!
  
  viewerCanCreateRepositories: Boolean!
  
  viewerCanCreateTeams: Boolean!
  
  viewerCanSponsor: Boolean!
  
  viewerIsAMember: Boolean!
  
  viewerIsSponsoring: Boolean!
  
  websiteUrl: URI
}
union OrganizationAuditEntry = MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry
type OrganizationAuditEntryConnection {
  
  edges: [OrganizationAuditEntryEdge]
  
  nodes: [OrganizationAuditEntry]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
interface OrganizationAuditEntryData {
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
}
type OrganizationAuditEntryEdge {
  
  cursor: String!
  
  node: OrganizationAuditEntry
}
type OrganizationConnection {
  
  edges: [OrganizationEdge]
  
  nodes: [Organization]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type OrganizationEdge {
  
  cursor: String!
  
  node: Organization
}
type OrganizationIdentityProvider implements Node {
  
  digestMethod: URI
  
  externalIdentities(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): ExternalIdentityConnection!
  id: ID!
  
  idpCertificate: X509Certificate
  
  issuer: String
  
  organization: Organization
  
  signatureMethod: URI
  
  ssoUrl: URI
}
type OrganizationInvitation implements Node {
  
  createdAt: DateTime!
  
  email: String
  id: ID!
  
  invitationType: OrganizationInvitationType!
  
  invitee: User
  
  inviter: User!
  
  organization: Organization!
  
  role: OrganizationInvitationRole!
}
type OrganizationInvitationConnection {
  
  edges: [OrganizationInvitationEdge]
  
  nodes: [OrganizationInvitation]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type OrganizationInvitationEdge {
  
  cursor: String!
  
  node: OrganizationInvitation
}
enum OrganizationInvitationRole {
  
  ADMIN
  
  BILLING_MANAGER
  
  DIRECT_MEMBER
  
  REINSTATE
}
enum OrganizationInvitationType {
  
  EMAIL
  
  USER
}
type OrganizationMemberConnection {
  
  edges: [OrganizationMemberEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type OrganizationMemberEdge {
  
  cursor: String!
  
  hasTwoFactorEnabled: Boolean
  
  node: User
  
  role: OrganizationMemberRole
}
enum OrganizationMemberRole {
  
  ADMIN
  
  MEMBER
}
enum OrganizationMembersCanCreateRepositoriesSettingValue {
  
  ALL
  
  DISABLED
  
  PRIVATE
}
input OrganizationOrder {
  
  direction: OrderDirection!
  
  field: OrganizationOrderField!
}
enum OrganizationOrderField {
  
  CREATED_AT
  
  LOGIN
}
type OrganizationTeamsHovercardContext implements HovercardContext {
  
  message: String!
  
  octicon: String!
  
  relevantTeams(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): TeamConnection!
  
  teamsResourcePath: URI!
  
  teamsUrl: URI!
  
  totalTeamCount: Int!
}
type OrganizationsHovercardContext implements HovercardContext {
  
  message: String!
  
  octicon: String!
  
  relevantOrganizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): OrganizationConnection!
  
  totalOrganizationCount: Int!
}
type Package implements Node {
  id: ID!
  
  latestVersion: PackageVersion
  
  name: String!
  
  packageType: PackageType!
  
  repository: Repository
  
  statistics: PackageStatistics
  
  version(
    
    version: String!
  ): PackageVersion
  
  versions(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: PackageVersionOrder = {field: CREATED_AT, direction: DESC}
  ): PackageVersionConnection!
}
type PackageConnection {
  
  edges: [PackageEdge]
  
  nodes: [Package]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PackageEdge {
  
  cursor: String!
  
  node: Package
}
type PackageFile implements Node {
  id: ID!
  
  md5: String
  
  name: String!
  
  packageVersion: PackageVersion
  
  sha1: String
  
  sha256: String
  
  size: Int
  
  updatedAt: DateTime!
  
  url: URI
}
type PackageFileConnection {
  
  edges: [PackageFileEdge]
  
  nodes: [PackageFile]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PackageFileEdge {
  
  cursor: String!
  
  node: PackageFile
}
input PackageFileOrder {
  
  direction: OrderDirection
  
  field: PackageFileOrderField
}
enum PackageFileOrderField {
  
  CREATED_AT
}
input PackageOrder {
  
  direction: OrderDirection
  
  field: PackageOrderField
}
enum PackageOrderField {
  
  CREATED_AT
}
interface PackageOwner {
  id: ID!
  
  packages(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    names: [String]
    
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    
    packageType: PackageType
    
    repositoryId: ID
  ): PackageConnection!
}
type PackageStatistics {
  
  downloadsTotalCount: Int!
}
type PackageTag implements Node {
  id: ID!
  
  name: String!
  
  version: PackageVersion
}
enum PackageType {
  
  DEBIAN
  
  DOCKER
  
  MAVEN
  
  NPM
  
  NUGET
  
  PYPI
  
  RUBYGEMS
}
type PackageVersion implements Node {
  
  files(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: PackageFileOrder = {field: CREATED_AT, direction: ASC}
  ): PackageFileConnection!
  id: ID!
  
  package: Package
  
  platform: String
  
  preRelease: Boolean!
  
  readme: String
  
  release: Release
  
  statistics: PackageVersionStatistics
  
  summary: String
  
  version: String!
}
type PackageVersionConnection {
  
  edges: [PackageVersionEdge]
  
  nodes: [PackageVersion]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PackageVersionEdge {
  
  cursor: String!
  
  node: PackageVersion
}
input PackageVersionOrder {
  
  direction: OrderDirection
  
  field: PackageVersionOrderField
}
enum PackageVersionOrderField {
  
  CREATED_AT
}
type PackageVersionStatistics {
  
  downloadsTotalCount: Int!
}
type PageInfo {
  
  endCursor: String
  
  hasNextPage: Boolean!
  
  hasPreviousPage: Boolean!
  
  startCursor: String
}
union PermissionGranter = Organization | Repository | Team
type PermissionSource {
  
  organization: Organization!
  
  permission: DefaultRepositoryPermissionField!
  
  source: PermissionGranter!
}
input PinIssueInput {
  
  clientMutationId: String
  
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type PinIssuePayload {
  
  clientMutationId: String
  
  issue: Issue
}
union PinnableItem = Gist | Repository
type PinnableItemConnection {
  
  edges: [PinnableItemEdge]
  
  nodes: [PinnableItem]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PinnableItemEdge {
  
  cursor: String!
  
  node: PinnableItem
}
enum PinnableItemType {
  
  GIST
  
  ISSUE
  
  ORGANIZATION
  
  PROJECT
  
  PULL_REQUEST
  
  REPOSITORY
  
  TEAM
  
  USER
}
type PinnedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  issue: Issue!
}
type PinnedIssue implements Node @preview(toggledBy: "elektra-preview") {
  
  databaseId: Int
  id: ID!
  
  issue: Issue!
  
  pinnedBy: Actor!
  
  repository: Repository!
}
type PinnedIssueConnection @preview(toggledBy: "elektra-preview") {
  
  edges: [PinnedIssueEdge]
  
  nodes: [PinnedIssue]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PinnedIssueEdge @preview(toggledBy: "elektra-preview") {
  
  cursor: String!
  
  node: PinnedIssue
}
scalar PreciseDateTime
type PrivateRepositoryForkingDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type PrivateRepositoryForkingEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type ProfileItemShowcase {
  
  hasPinnedItems: Boolean!
  
  items(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PinnableItemConnection!
}
interface ProfileOwner {
  
  anyPinnableItems(
    
    type: PinnableItemType
  ): Boolean!
  
  email: String
  id: ID!
  
  itemShowcase: ProfileItemShowcase!
  
  location: String
  
  login: String!
  
  name: String
  
  pinnableItems(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  
  pinnedItems(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  
  pinnedItemsRemaining: Int!
  
  viewerCanChangePinnedItems: Boolean!
  
  websiteUrl: URI
}
type Project implements Closable & Node & Updatable {
  
  body: String
  
  bodyHTML: HTML!
  
  closed: Boolean!
  
  closedAt: DateTime
  
  columns(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): ProjectColumnConnection!
  
  createdAt: DateTime!
  
  creator: Actor
  
  databaseId: Int
  id: ID!
  
  name: String!
  
  number: Int!
  
  owner: ProjectOwner!
  
  pendingCards(
    
    after: String
    
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    
    before: String
    
    first: Int
    
    last: Int
  ): ProjectCardConnection!
  
  progress: ProjectProgress!
  
  resourcePath: URI!
  
  state: ProjectState!
  
  updatedAt: DateTime!
  
  url: URI!
  
  viewerCanUpdate: Boolean!
}
type ProjectCard implements Node {
  
  column: ProjectColumn
  
  content: ProjectCardItem
  
  createdAt: DateTime!
  
  creator: Actor
  
  databaseId: Int
  id: ID!
  
  isArchived: Boolean!
  
  note: String
  
  project: Project!
  
  resourcePath: URI!
  
  state: ProjectCardState
  
  updatedAt: DateTime!
  
  url: URI!
}
enum ProjectCardArchivedState {
  
  ARCHIVED
  
  NOT_ARCHIVED
}
type ProjectCardConnection {
  
  edges: [ProjectCardEdge]
  
  nodes: [ProjectCard]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ProjectCardEdge {
  
  cursor: String!
  
  node: ProjectCard
}
input ProjectCardImport {
  
  number: Int!
  
  repository: String!
}
union ProjectCardItem = Issue | PullRequest
enum ProjectCardState {
  
  CONTENT_ONLY
  
  NOTE_ONLY
  
  REDACTED
}
type ProjectColumn implements Node {
  
  cards(
    
    after: String
    
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    
    before: String
    
    first: Int
    
    last: Int
  ): ProjectCardConnection!
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  name: String!
  
  project: Project!
  
  purpose: ProjectColumnPurpose
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
}
type ProjectColumnConnection {
  
  edges: [ProjectColumnEdge]
  
  nodes: [ProjectColumn]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ProjectColumnEdge {
  
  cursor: String!
  
  node: ProjectColumn
}
input ProjectColumnImport {
  
  columnName: String!
  
  issues: [ProjectCardImport!]
  
  position: Int!
}
enum ProjectColumnPurpose {
  
  DONE
  
  IN_PROGRESS
  
  TODO
}
type ProjectConnection {
  
  edges: [ProjectEdge]
  
  nodes: [Project]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ProjectEdge {
  
  cursor: String!
  
  node: Project
}
input ProjectOrder {
  
  direction: OrderDirection!
  
  field: ProjectOrderField!
}
enum ProjectOrderField {
  
  CREATED_AT
  
  NAME
  
  UPDATED_AT
}
interface ProjectOwner {
  id: ID!
  
  project(
    
    number: Int!
  ): Project
  
  projects(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ProjectOrder
    
    search: String
    
    states: [ProjectState!]
  ): ProjectConnection!
  
  projectsResourcePath: URI!
  
  projectsUrl: URI!
  
  viewerCanCreateProjects: Boolean!
}
type ProjectProgress {
  
  doneCount: Int!
  
  donePercentage: Float!
  
  enabled: Boolean!
  
  inProgressCount: Int!
  
  inProgressPercentage: Float!
  
  todoCount: Int!
  
  todoPercentage: Float!
}
enum ProjectState {
  
  CLOSED
  
  OPEN
}
enum ProjectTemplate {
  
  AUTOMATED_KANBAN_V2
  
  AUTOMATED_REVIEWS_KANBAN
  
  BASIC_KANBAN
  
  BUG_TRIAGE
}
type PublicKey implements Node {
  
  accessedAt: DateTime
  
  createdAt: DateTime
  
  fingerprint: String!
  id: ID!
  
  isReadOnly: Boolean
  
  key: String!
  
  updatedAt: DateTime
}
type PublicKeyConnection {
  
  edges: [PublicKeyEdge]
  
  nodes: [PublicKey]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PublicKeyEdge {
  
  cursor: String!
  
  node: PublicKey
}
type PullRequest implements Assignable & Closable & Comment & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  
  activeLockReason: LockReason
  
  additions: Int!
  
  assignees(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  baseRef: Ref
  
  baseRefName: String!
  
  baseRefOid: GitObjectID!
  
  baseRepository: Repository
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  canBeRebased: Boolean! @preview(toggledBy: "merge-info-preview")
  
  changedFiles: Int!
  
  checksResourcePath: URI!
  
  checksUrl: URI!
  
  closed: Boolean!
  
  closedAt: DateTime
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: IssueCommentOrder
  ): IssueCommentConnection!
  
  commits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PullRequestCommitConnection!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  deletions: Int!
  
  editor: Actor
  
  files(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PullRequestChangedFileConnection
  
  headRef: Ref
  
  headRefName: String!
  
  headRefOid: GitObjectID!
  
  headRepository: Repository
  
  headRepositoryOwner: RepositoryOwner
  
  hovercard(
    
    includeNotificationContexts: Boolean = true
  ): Hovercard!
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isCrossRepository: Boolean!
  
  isDraft: Boolean!
  
  isReadByViewer: Boolean
  
  labels(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
  
  lastEditedAt: DateTime
  
  latestOpinionatedReviews(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    writersOnly: Boolean = false
  ): PullRequestReviewConnection
  
  latestReviews(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PullRequestReviewConnection
  
  locked: Boolean!
  
  maintainerCanModify: Boolean!
  
  mergeCommit: Commit
  
  mergeStateStatus: MergeStateStatus! @preview(toggledBy: "merge-info-preview")
  
  mergeable: MergeableState!
  
  merged: Boolean!
  
  mergedAt: DateTime
  
  mergedBy: Actor
  
  milestone: Milestone
  
  number: Int!
  
  participants(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
  
  permalink: URI!
  
  potentialMergeCommit: Commit
  
  projectCards(
    
    after: String
    
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    
    before: String
    
    first: Int
    
    last: Int
  ): ProjectCardConnection!
  
  publishedAt: DateTime
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  revertResourcePath: URI!
  
  revertUrl: URI!
  
  reviewDecision: PullRequestReviewDecision
  
  reviewRequests(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): ReviewRequestConnection
  
  reviewThreads(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PullRequestReviewThreadConnection!
  
  reviews(
    
    after: String
    
    author: String
    
    before: String
    
    first: Int
    
    last: Int
    
    states: [PullRequestReviewState!]
  ): PullRequestReviewConnection
  
  state: PullRequestState!
  
  suggestedReviewers: [SuggestedReviewer]!
  
  timeline(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    since: DateTime
  ): PullRequestTimelineConnection! @deprecated(reason: "`timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.")
  
  timelineItems(
    
    after: String
    
    before: String
    
    first: Int
    
    itemTypes: [PullRequestTimelineItemsItemType!]
    
    last: Int
    
    since: DateTime
    
    skip: Int
  ): PullRequestTimelineItemsConnection!
  
  title: String!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanApplySuggestion: Boolean!
  
  viewerCanDeleteHeadRef: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanSubscribe: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
  
  viewerMergeBodyText(
    
    mergeType: PullRequestMergeMethod
  ): String!
  
  viewerMergeHeadlineText(
    
    mergeType: PullRequestMergeMethod
  ): String!
  
  viewerSubscription: SubscriptionState
}
type PullRequestChangedFile {
  
  additions: Int!
  
  deletions: Int!
  
  path: String!
  
  viewerViewedState: FileViewedState!
}
type PullRequestChangedFileConnection {
  
  edges: [PullRequestChangedFileEdge]
  
  nodes: [PullRequestChangedFile]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PullRequestChangedFileEdge {
  
  cursor: String!
  
  node: PullRequestChangedFile
}
type PullRequestCommit implements Node & UniformResourceLocatable {
  
  commit: Commit!
  id: ID!
  
  pullRequest: PullRequest!
  
  resourcePath: URI!
  
  url: URI!
}
type PullRequestCommitCommentThread implements Node & RepositoryNode {
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CommitCommentConnection!
  
  commit: Commit!
  id: ID!
  
  path: String
  
  position: Int
  
  pullRequest: PullRequest!
  
  repository: Repository!
}
type PullRequestCommitConnection {
  
  edges: [PullRequestCommitEdge]
  
  nodes: [PullRequestCommit]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PullRequestCommitEdge {
  
  cursor: String!
  
  node: PullRequestCommit
}
type PullRequestConnection {
  
  edges: [PullRequestEdge]
  
  nodes: [PullRequest]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PullRequestContributionsByRepository {
  
  contributions(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestContributionConnection!
  
  repository: Repository!
}
type PullRequestEdge {
  
  cursor: String!
  
  node: PullRequest
}
enum PullRequestMergeMethod {
  
  MERGE
  
  REBASE
  
  SQUASH
}
input PullRequestOrder {
  
  direction: OrderDirection!
  
  field: PullRequestOrderField!
}
enum PullRequestOrderField {
  
  CREATED_AT
  
  UPDATED_AT
}
type PullRequestReview implements Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  authorCanPushToRepository: Boolean!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PullRequestReviewCommentConnection!
  
  commit: Commit
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  lastEditedAt: DateTime
  
  onBehalfOf(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): TeamConnection!
  
  publishedAt: DateTime
  
  pullRequest: PullRequest!
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  repository: Repository!
  
  resourcePath: URI!
  
  state: PullRequestReviewState!
  
  submittedAt: DateTime
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
}
type PullRequestReviewComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  commit: Commit
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  diffHunk: String!
  
  draftedAt: DateTime!
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isMinimized: Boolean!
  
  lastEditedAt: DateTime
  
  minimizedReason: String
  
  originalCommit: Commit
  
  originalPosition: Int!
  
  outdated: Boolean!
  
  path: String!
  
  position: Int
  
  publishedAt: DateTime
  
  pullRequest: PullRequest!
  
  pullRequestReview: PullRequestReview
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  replyTo: PullRequestReviewComment
  
  repository: Repository!
  
  resourcePath: URI!
  
  state: PullRequestReviewCommentState!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanMinimize: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
}
type PullRequestReviewCommentConnection {
  
  edges: [PullRequestReviewCommentEdge]
  
  nodes: [PullRequestReviewComment]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PullRequestReviewCommentEdge {
  
  cursor: String!
  
  node: PullRequestReviewComment
}
enum PullRequestReviewCommentState {
  
  PENDING
  
  SUBMITTED
}
type PullRequestReviewConnection {
  
  edges: [PullRequestReviewEdge]
  
  nodes: [PullRequestReview]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PullRequestReviewContributionsByRepository {
  
  contributions(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestReviewContributionConnection!
  
  repository: Repository!
}
enum PullRequestReviewDecision {
  
  APPROVED
  
  CHANGES_REQUESTED
  
  REVIEW_REQUIRED
}
type PullRequestReviewEdge {
  
  cursor: String!
  
  node: PullRequestReview
}
enum PullRequestReviewEvent {
  
  APPROVE
  
  COMMENT
  
  DISMISS
  
  REQUEST_CHANGES
}
enum PullRequestReviewState {
  
  APPROVED
  
  CHANGES_REQUESTED
  
  COMMENTED
  
  DISMISSED
  
  PENDING
}
type PullRequestReviewThread implements Node {
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    skip: Int
  ): PullRequestReviewCommentConnection!
  
  diffSide: DiffSide!
  id: ID!
  
  isCollapsed: Boolean!
  
  isOutdated: Boolean!
  
  isResolved: Boolean!
  
  line: Int
  
  originalLine: Int
  
  originalStartLine: Int
  
  path: String!
  
  pullRequest: PullRequest!
  
  repository: Repository!
  
  resolvedBy: User
  
  startDiffSide: DiffSide
  
  startLine: Int
  
  viewerCanReply: Boolean!
  
  viewerCanResolve: Boolean!
  
  viewerCanUnresolve: Boolean!
}
type PullRequestReviewThreadConnection {
  
  edges: [PullRequestReviewThreadEdge]
  
  nodes: [PullRequestReviewThread]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PullRequestReviewThreadEdge {
  
  cursor: String!
  
  node: PullRequestReviewThread
}
type PullRequestRevisionMarker {
  
  createdAt: DateTime!
  
  lastSeenCommit: Commit!
  
  pullRequest: PullRequest!
}
enum PullRequestState {
  
  CLOSED
  
  MERGED
  
  OPEN
}
type PullRequestTimelineConnection {
  
  edges: [PullRequestTimelineItemEdge]
  
  nodes: [PullRequestTimelineItem]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
union PullRequestTimelineItem = AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent
type PullRequestTimelineItemEdge {
  
  cursor: String!
  
  node: PullRequestTimelineItem
}
union PullRequestTimelineItems = AddedToProjectEvent | AssignedEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent
type PullRequestTimelineItemsConnection {
  
  edges: [PullRequestTimelineItemsEdge]
  
  filteredCount: Int!
  
  nodes: [PullRequestTimelineItems]
  
  pageCount: Int!
  
  pageInfo: PageInfo!
  
  totalCount: Int!
  
  updatedAt: DateTime!
}
type PullRequestTimelineItemsEdge {
  
  cursor: String!
  
  node: PullRequestTimelineItems
}
enum PullRequestTimelineItemsItemType {
  
  ADDED_TO_PROJECT_EVENT
  
  ASSIGNED_EVENT
  
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT
  
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT
  
  BASE_REF_CHANGED_EVENT
  
  BASE_REF_DELETED_EVENT
  
  BASE_REF_FORCE_PUSHED_EVENT
  
  CLOSED_EVENT
  
  COMMENT_DELETED_EVENT
  
  CONNECTED_EVENT
  
  CONVERTED_NOTE_TO_ISSUE_EVENT
  
  CONVERT_TO_DRAFT_EVENT
  
  CROSS_REFERENCED_EVENT
  
  DEMILESTONED_EVENT
  
  DEPLOYED_EVENT
  
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT
  
  DISCONNECTED_EVENT
  
  HEAD_REF_DELETED_EVENT
  
  HEAD_REF_FORCE_PUSHED_EVENT
  
  HEAD_REF_RESTORED_EVENT
  
  ISSUE_COMMENT
  
  LABELED_EVENT
  
  LOCKED_EVENT
  
  MARKED_AS_DUPLICATE_EVENT
  
  MENTIONED_EVENT
  
  MERGED_EVENT
  
  MILESTONED_EVENT
  
  MOVED_COLUMNS_IN_PROJECT_EVENT
  
  PINNED_EVENT
  
  PULL_REQUEST_COMMIT
  
  PULL_REQUEST_COMMIT_COMMENT_THREAD
  
  PULL_REQUEST_REVIEW
  
  PULL_REQUEST_REVIEW_THREAD
  
  PULL_REQUEST_REVISION_MARKER
  
  READY_FOR_REVIEW_EVENT
  
  REFERENCED_EVENT
  
  REMOVED_FROM_PROJECT_EVENT
  
  RENAMED_TITLE_EVENT
  
  REOPENED_EVENT
  
  REVIEW_DISMISSED_EVENT
  
  REVIEW_REQUESTED_EVENT
  
  REVIEW_REQUEST_REMOVED_EVENT
  
  SUBSCRIBED_EVENT
  
  TRANSFERRED_EVENT
  
  UNASSIGNED_EVENT
  
  UNLABELED_EVENT
  
  UNLOCKED_EVENT
  
  UNMARKED_AS_DUPLICATE_EVENT
  
  UNPINNED_EVENT
  
  UNSUBSCRIBED_EVENT
  
  USER_BLOCKED_EVENT
}
enum PullRequestUpdateState {
  
  CLOSED
  
  OPEN
}
type Push implements Node {
  id: ID!
  
  nextSha: GitObjectID
  
  permalink: URI!
  
  previousSha: GitObjectID
  
  pusher: User!
  
  repository: Repository!
}
type PushAllowance implements Node {
  
  actor: PushAllowanceActor
  
  branchProtectionRule: BranchProtectionRule
  id: ID!
}
union PushAllowanceActor = App | Team | User
type PushAllowanceConnection {
  
  edges: [PushAllowanceEdge]
  
  nodes: [PushAllowance]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type PushAllowanceEdge {
  
  cursor: String!
  
  node: PushAllowance
}
type Query {
  
  codeOfConduct(
    
    key: String!
  ): CodeOfConduct
  
  codesOfConduct: [CodeOfConduct]
  
  enterprise(
    
    invitationToken: String
    
    slug: String!
  ): Enterprise
  
  enterpriseAdministratorInvitation(
    
    enterpriseSlug: String!
    
    role: EnterpriseAdministratorRole!
    
    userLogin: String!
  ): EnterpriseAdministratorInvitation
  
  enterpriseAdministratorInvitationByToken(
    
    invitationToken: String!
  ): EnterpriseAdministratorInvitation
  
  license(
    
    key: String!
  ): License
  
  licenses: [License]!
  
  marketplaceCategories(
    
    excludeEmpty: Boolean
    
    excludeSubcategories: Boolean
    
    includeCategories: [String!]
  ): [MarketplaceCategory!]!
  
  marketplaceCategory(
    
    slug: String!
    
    useTopicAliases: Boolean
  ): MarketplaceCategory
  
  marketplaceListing(
    
    slug: String!
  ): MarketplaceListing
  
  marketplaceListings(
    
    adminId: ID
    
    after: String
    
    allStates: Boolean
    
    before: String
    
    categorySlug: String
    
    first: Int
    
    last: Int
    
    organizationId: ID
    
    primaryCategoryOnly: Boolean = false
    
    slugs: [String]
    
    useTopicAliases: Boolean
    
    viewerCanAdmin: Boolean
    
    withFreeTrialsOnly: Boolean = false
  ): MarketplaceListingConnection!
  
  meta: GitHubMetadata!
  
  node(
    
    id: ID!
  ): Node
  
  nodes(
    
    ids: [ID!]!
  ): [Node]!
  
  organization(
    
    login: String!
  ): Organization
  
  rateLimit(
    
    dryRun: Boolean = false
  ): RateLimit
  
  relay: Query!
  
  repository(
    
    name: String!
    
    owner: String!
  ): Repository
  
  repositoryOwner(
    
    login: String!
  ): RepositoryOwner
  
  resource(
    
    url: URI!
  ): UniformResourceLocatable
  
  search(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    query: String!
    
    type: SearchType!
  ): SearchResultItemConnection!
  
  securityAdvisories(
    
    after: String
    
    before: String
    
    first: Int
    
    identifier: SecurityAdvisoryIdentifierFilter
    
    last: Int
    
    orderBy: SecurityAdvisoryOrder = {field: UPDATED_AT, direction: DESC}
    
    publishedSince: DateTime
    
    updatedSince: DateTime
  ): SecurityAdvisoryConnection!
  
  securityAdvisory(
    
    ghsaId: String!
  ): SecurityAdvisory
  
  securityVulnerabilities(
    
    after: String
    
    before: String
    
    ecosystem: SecurityAdvisoryEcosystem
    
    first: Int
    
    last: Int
    
    orderBy: SecurityVulnerabilityOrder = {field: UPDATED_AT, direction: DESC}
    
    package: String
    
    severities: [SecurityAdvisorySeverity!]
  ): SecurityVulnerabilityConnection!
  
  sponsorsListing(
    
    slug: String!
  ): SponsorsListing @deprecated(reason: "`Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.")
  
  topic(
    
    name: String!
  ): Topic
  
  user(
    
    login: String!
  ): User
  
  viewer: User!
}
type RateLimit {
  
  cost: Int!
  
  limit: Int!
  
  nodeCount: Int!
  
  remaining: Int!
  
  resetAt: DateTime!
  
  used: Int!
}
interface Reactable {
  
  databaseId: Int
  id: ID!
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  viewerCanReact: Boolean!
}
type ReactingUserConnection {
  
  edges: [ReactingUserEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ReactingUserEdge {
  
  cursor: String!
  node: User!
  
  reactedAt: DateTime!
}
type Reaction implements Node {
  
  content: ReactionContent!
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  reactable: Reactable!
  
  user: User
}
type ReactionConnection {
  
  edges: [ReactionEdge]
  
  nodes: [Reaction]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
  
  viewerHasReacted: Boolean!
}
enum ReactionContent {
  
  CONFUSED
  
  EYES
  
  HEART
  
  HOORAY
  
  LAUGH
  
  ROCKET
  
  THUMBS_DOWN
  
  THUMBS_UP
}
type ReactionEdge {
  
  cursor: String!
  
  node: Reaction
}
type ReactionGroup {
  
  content: ReactionContent!
  
  createdAt: DateTime
  
  subject: Reactable!
  
  users(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): ReactingUserConnection!
  
  viewerHasReacted: Boolean!
}
input ReactionOrder {
  
  direction: OrderDirection!
  
  field: ReactionOrderField!
}
enum ReactionOrderField {
  
  CREATED_AT
}
type ReadyForReviewEvent implements Node & UniformResourceLocatable {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
  
  resourcePath: URI!
  
  url: URI!
}
type Ref implements Node {
  
  associatedPullRequests(
    
    after: String
    
    baseRefName: String
    
    before: String
    
    first: Int
    
    headRefName: String
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [PullRequestState!]
  ): PullRequestConnection!
  
  branchProtectionRule: BranchProtectionRule
  id: ID!
  
  name: String!
  
  prefix: String!
  
  refUpdateRule: RefUpdateRule
  
  repository: Repository!
  
  target: GitObject
}
type RefConnection {
  
  edges: [RefEdge]
  
  nodes: [Ref]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type RefEdge {
  
  cursor: String!
  
  node: Ref
}
input RefOrder {
  
  direction: OrderDirection!
  
  field: RefOrderField!
}
enum RefOrderField {
  
  ALPHABETICAL
  
  TAG_COMMIT_DATE
}
input RefUpdate @preview(toggledBy: "update-refs-preview") {
  
  afterOid: GitObjectID!
  
  beforeOid: GitObjectID
  
  force: Boolean = false
  
  name: GitRefname!
}
type RefUpdateRule {
  
  allowsDeletions: Boolean!
  
  allowsForcePushes: Boolean!
  
  pattern: String!
  
  requiredApprovingReviewCount: Int
  
  requiredStatusCheckContexts: [String]
  
  requiresLinearHistory: Boolean!
  
  requiresSignatures: Boolean!
  
  viewerCanPush: Boolean!
}
type ReferencedEvent implements Node {
  
  actor: Actor
  
  commit: Commit
  
  commitRepository: Repository!
  
  createdAt: DateTime!
  id: ID!
  
  isCrossRepository: Boolean!
  
  isDirectReference: Boolean!
  
  subject: ReferencedSubject!
}
union ReferencedSubject = Issue | PullRequest
input RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
}
type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload {
  
  clientMutationId: String
  
  identityProvider: EnterpriseIdentityProvider
}
type Release implements Node & UniformResourceLocatable {
  
  author: User
  
  createdAt: DateTime!
  
  description: String
  
  descriptionHTML: HTML
  id: ID!
  
  isDraft: Boolean!
  
  isPrerelease: Boolean!
  
  name: String
  
  publishedAt: DateTime
  
  releaseAssets(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    name: String
  ): ReleaseAssetConnection!
  
  resourcePath: URI!
  
  shortDescriptionHTML(
    
    limit: Int = 200
  ): HTML
  
  tag: Ref
  
  tagName: String!
  
  updatedAt: DateTime!
  
  url: URI!
}
type ReleaseAsset implements Node {
  
  contentType: String!
  
  createdAt: DateTime!
  
  downloadCount: Int!
  
  downloadUrl: URI!
  id: ID!
  
  name: String!
  
  release: Release
  
  size: Int!
  
  updatedAt: DateTime!
  
  uploadedBy: User!
  
  url: URI!
}
type ReleaseAssetConnection {
  
  edges: [ReleaseAssetEdge]
  
  nodes: [ReleaseAsset]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ReleaseAssetEdge {
  
  cursor: String!
  
  node: ReleaseAsset
}
type ReleaseConnection {
  
  edges: [ReleaseEdge]
  
  nodes: [Release]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ReleaseEdge {
  
  cursor: String!
  
  node: Release
}
input ReleaseOrder {
  
  direction: OrderDirection!
  
  field: ReleaseOrderField!
}
enum ReleaseOrderField {
  
  CREATED_AT
  
  NAME
}
input RemoveAssigneesFromAssignableInput {
  
  assignableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Assignable")
  
  assigneeIds: [ID!]! @possibleTypes(concreteTypes: ["User"])
  
  clientMutationId: String
}
type RemoveAssigneesFromAssignablePayload {
  
  assignable: Assignable
  
  clientMutationId: String
}
input RemoveEnterpriseAdminInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  login: String!
}
type RemoveEnterpriseAdminPayload {
  
  admin: User
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
  
  viewer: User
}
input RemoveEnterpriseIdentityProviderInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
}
type RemoveEnterpriseIdentityProviderPayload {
  
  clientMutationId: String
  
  identityProvider: EnterpriseIdentityProvider
}
input RemoveEnterpriseOrganizationInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type RemoveEnterpriseOrganizationPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  organization: Organization
  
  viewer: User
}
input RemoveLabelsFromLabelableInput {
  
  clientMutationId: String
  
  labelIds: [ID!]! @possibleTypes(concreteTypes: ["Label"])
  
  labelableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Labelable")
}
type RemoveLabelsFromLabelablePayload {
  
  clientMutationId: String
  
  labelable: Labelable
}
input RemoveOutsideCollaboratorInput {
  
  clientMutationId: String
  
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
  
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type RemoveOutsideCollaboratorPayload {
  
  clientMutationId: String
  
  removedUser: User
}
input RemoveReactionInput {
  
  clientMutationId: String
  
  content: ReactionContent!
  
  subjectId: ID! @possibleTypes(concreteTypes: ["CommitComment", "Issue", "IssueComment", "PullRequest", "PullRequestReview", "PullRequestReviewComment", "TeamDiscussion", "TeamDiscussionComment"], abstractType: "Reactable")
}
type RemoveReactionPayload {
  
  clientMutationId: String
  
  reaction: Reaction
  
  subject: Reactable
}
input RemoveStarInput {
  
  clientMutationId: String
  
  starrableId: ID! @possibleTypes(concreteTypes: ["Gist", "Repository", "Topic"], abstractType: "Starrable")
}
type RemoveStarPayload {
  
  clientMutationId: String
  
  starrable: Starrable
}
type RemovedFromProjectEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  id: ID!
  
  project: Project @preview(toggledBy: "starfox-preview")
  
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
type RenamedTitleEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  currentTitle: String!
  id: ID!
  
  previousTitle: String!
  
  subject: RenamedTitleSubject!
}
union RenamedTitleSubject = Issue | PullRequest
input ReopenIssueInput {
  
  clientMutationId: String
  
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type ReopenIssuePayload {
  
  clientMutationId: String
  
  issue: Issue
}
input ReopenPullRequestInput {
  
  clientMutationId: String
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type ReopenPullRequestPayload {
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
type ReopenedEvent implements Node {
  
  actor: Actor
  
  closable: Closable!
  
  createdAt: DateTime!
  id: ID!
}
type RepoAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: RepoAccessAuditEntryVisibility
}
enum RepoAccessAuditEntryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepoAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: RepoAddMemberAuditEntryVisibility
}
enum RepoAddMemberAuditEntryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepoAddTopicAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  topic: Topic
  
  topicName: String
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoArchivedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: RepoArchivedAuditEntryVisibility
}
enum RepoArchivedAuditEntryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepoChangeMergeSettingAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  isEnabled: Boolean
  
  mergeType: RepoChangeMergeSettingAuditEntryMergeType
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum RepoChangeMergeSettingAuditEntryMergeType {
  
  MERGE
  
  REBASE
  
  SQUASH
}
type RepoConfigDisableAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigDisableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigDisableContributorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigDisableSockpuppetDisallowedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigEnableAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigEnableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigEnableContributorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigEnableSockpuppetDisallowedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigLockAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoConfigUnlockAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepoCreateAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  forkParentName: String
  
  forkSourceName: String
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: RepoCreateAuditEntryVisibility
}
enum RepoCreateAuditEntryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepoDestroyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: RepoDestroyAuditEntryVisibility
}
enum RepoDestroyAuditEntryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepoRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
  
  visibility: RepoRemoveMemberAuditEntryVisibility
}
enum RepoRemoveMemberAuditEntryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepoRemoveTopicAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  topic: Topic
  
  topicName: String
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
enum ReportedContentClassifiers {
  
  ABUSE
  
  DUPLICATE
  
  OFF_TOPIC
  
  OUTDATED
  
  RESOLVED
  
  SPAM
}
type Repository implements Node & PackageOwner & ProjectOwner & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable {
  
  assignableUsers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    query: String
  ): UserConnection!
  
  branchProtectionRules(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): BranchProtectionRuleConnection!
  
  codeOfConduct: CodeOfConduct
  
  collaborators(
    
    affiliation: CollaboratorAffiliation
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    query: String
  ): RepositoryCollaboratorConnection
  
  commitComments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CommitCommentConnection!
  
  contactLinks: [RepositoryContactLink!]
  
  createdAt: DateTime!
  
  databaseId: Int
  
  defaultBranchRef: Ref
  
  deleteBranchOnMerge: Boolean!
  
  dependencyGraphManifests(
    
    after: String
    
    before: String
    
    dependenciesAfter: String
    
    dependenciesFirst: Int
    
    first: Int
    
    last: Int
    
    withDependencies: Boolean
  ): DependencyGraphManifestConnection @preview(toggledBy: "hawkgirl-preview")
  
  deployKeys(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): DeployKeyConnection!
  
  deployments(
    
    after: String
    
    before: String
    
    environments: [String!]
    
    first: Int
    
    last: Int
    
    orderBy: DeploymentOrder = {field: CREATED_AT, direction: ASC}
  ): DeploymentConnection!
  
  description: String
  
  descriptionHTML: HTML!
  
  diskUsage: Int
  
  forkCount: Int!
  
  forks(
    
    affiliations: [RepositoryAffiliation]
    
    after: String
    
    before: String
    
    first: Int
    
    isLocked: Boolean
    
    last: Int
    
    orderBy: RepositoryOrder
    
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  
  fundingLinks: [FundingLink!]!
  
  hasIssuesEnabled: Boolean!
  
  hasProjectsEnabled: Boolean!
  
  hasWikiEnabled: Boolean!
  
  homepageUrl: URI
  id: ID!
  
  interactionAbility: RepositoryInteractionAbility
  
  isArchived: Boolean!
  
  isBlankIssuesEnabled: Boolean!
  
  isDisabled: Boolean!
  
  isEmpty: Boolean!
  
  isFork: Boolean!
  
  isInOrganization: Boolean!
  
  isLocked: Boolean!
  
  isMirror: Boolean!
  
  isPrivate: Boolean!
  
  isSecurityPolicyEnabled: Boolean
  
  isTemplate: Boolean!
  
  isUserConfigurationRepository: Boolean!
  
  issue(
    
    number: Int!
  ): Issue
  
  issueOrPullRequest(
    
    number: Int!
  ): IssueOrPullRequest
  
  issueTemplates: [IssueTemplate!]
  
  issues(
    
    after: String
    
    before: String
    
    filterBy: IssueFilters
    
    first: Int
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [IssueState!]
  ): IssueConnection!
  
  label(
    
    name: String!
  ): Label
  
  labels(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
    
    query: String
  ): LabelConnection
  
  languages(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: LanguageOrder
  ): LanguageConnection
  
  licenseInfo: License
  
  lockReason: RepositoryLockReason
  
  mentionableUsers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    query: String
  ): UserConnection!
  
  mergeCommitAllowed: Boolean!
  
  milestone(
    
    number: Int!
  ): Milestone
  
  milestones(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: MilestoneOrder
    
    query: String
    
    states: [MilestoneState!]
  ): MilestoneConnection
  
  mirrorUrl: URI
  
  name: String!
  
  nameWithOwner: String!
  
  object(
    
    expression: String
    
    oid: GitObjectID
  ): GitObject
  
  openGraphImageUrl: URI!
  
  owner: RepositoryOwner!
  
  packages(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    names: [String]
    
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    
    packageType: PackageType
    
    repositoryId: ID
  ): PackageConnection!
  
  parent: Repository
  
  pinnedIssues(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PinnedIssueConnection @preview(toggledBy: "elektra-preview")
  
  primaryLanguage: Language
  
  project(
    
    number: Int!
  ): Project
  
  projects(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ProjectOrder
    
    search: String
    
    states: [ProjectState!]
  ): ProjectConnection!
  
  projectsResourcePath: URI!
  
  projectsUrl: URI!
  
  pullRequest(
    
    number: Int!
  ): PullRequest
  
  pullRequests(
    
    after: String
    
    baseRefName: String
    
    before: String
    
    first: Int
    
    headRefName: String
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [PullRequestState!]
  ): PullRequestConnection!
  
  pushedAt: DateTime
  
  rebaseMergeAllowed: Boolean!
  
  ref(
    
    qualifiedName: String!
  ): Ref
  
  refs(
    
    after: String
    
    before: String
    
    direction: OrderDirection
    
    first: Int
    
    last: Int
    
    orderBy: RefOrder
    
    query: String
    
    refPrefix: String!
  ): RefConnection
  
  release(
    
    tagName: String!
  ): Release
  
  releases(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ReleaseOrder
  ): ReleaseConnection!
  
  repositoryTopics(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): RepositoryTopicConnection!
  
  resourcePath: URI!
  
  securityPolicyUrl: URI
  
  shortDescriptionHTML(
    
    limit: Int = 200
  ): HTML!
  
  squashMergeAllowed: Boolean!
  
  sshUrl: GitSSHRemote!
  
  stargazerCount: Int!
  
  stargazers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: StarOrder
  ): StargazerConnection!
  
  submodules(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): SubmoduleConnection!
  
  tempCloneToken: String
  
  templateRepository: Repository
  
  updatedAt: DateTime!
  
  url: URI!
  
  usesCustomOpenGraphImage: Boolean!
  
  viewerCanAdminister: Boolean!
  
  viewerCanCreateProjects: Boolean!
  
  viewerCanSubscribe: Boolean!
  
  viewerCanUpdateTopics: Boolean!
  
  viewerDefaultCommitEmail: String
  
  viewerDefaultMergeMethod: PullRequestMergeMethod!
  
  viewerHasStarred: Boolean!
  
  viewerPermission: RepositoryPermission
  
  viewerPossibleCommitEmails: [String!]
  
  viewerSubscription: SubscriptionState
  
  vulnerabilityAlerts(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): RepositoryVulnerabilityAlertConnection
  
  watchers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserConnection!
}
enum RepositoryAffiliation {
  
  COLLABORATOR
  
  ORGANIZATION_MEMBER
  
  OWNER
}
interface RepositoryAuditEntryData {
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
}
type RepositoryCollaboratorConnection {
  
  edges: [RepositoryCollaboratorEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type RepositoryCollaboratorEdge {
  
  cursor: String!
  node: User!
  
  permission: RepositoryPermission!
  
  permissionSources: [PermissionSource!]
}
type RepositoryConnection {
  
  edges: [RepositoryEdge]
  
  nodes: [Repository]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
  
  totalDiskUsage: Int!
}
type RepositoryContactLink {
  
  about: String!
  
  name: String!
  
  url: URI!
}
enum RepositoryContributionType {
  
  COMMIT
  
  ISSUE
  
  PULL_REQUEST
  
  PULL_REQUEST_REVIEW
  
  REPOSITORY
}
type RepositoryEdge {
  
  cursor: String!
  
  node: Repository
}
interface RepositoryInfo {
  
  createdAt: DateTime!
  
  description: String
  
  descriptionHTML: HTML!
  
  forkCount: Int!
  
  hasIssuesEnabled: Boolean!
  
  hasProjectsEnabled: Boolean!
  
  hasWikiEnabled: Boolean!
  
  homepageUrl: URI
  
  isArchived: Boolean!
  
  isFork: Boolean!
  
  isInOrganization: Boolean!
  
  isLocked: Boolean!
  
  isMirror: Boolean!
  
  isPrivate: Boolean!
  
  isTemplate: Boolean!
  
  licenseInfo: License
  
  lockReason: RepositoryLockReason
  
  mirrorUrl: URI
  
  name: String!
  
  nameWithOwner: String!
  
  openGraphImageUrl: URI!
  
  owner: RepositoryOwner!
  
  pushedAt: DateTime
  
  resourcePath: URI!
  
  shortDescriptionHTML(
    
    limit: Int = 200
  ): HTML!
  
  updatedAt: DateTime!
  
  url: URI!
  
  usesCustomOpenGraphImage: Boolean!
}
type RepositoryInteractionAbility {
  
  expiresAt: DateTime
  
  limit: RepositoryInteractionLimit!
  
  origin: RepositoryInteractionLimitOrigin!
}
enum RepositoryInteractionLimit {
  
  COLLABORATORS_ONLY
  
  CONTRIBUTORS_ONLY
  
  EXISTING_USERS
  
  NO_LIMIT
}
enum RepositoryInteractionLimitExpiry {
  
  ONE_DAY
  
  ONE_MONTH
  
  ONE_WEEK
  
  SIX_MONTHS
  
  THREE_DAYS
}
enum RepositoryInteractionLimitOrigin {
  
  ORGANIZATION
  
  REPOSITORY
  
  USER
}
type RepositoryInvitation implements Node {
  
  email: String
  id: ID!
  
  invitee: User
  
  inviter: User!
  
  permalink: URI!
  
  permission: RepositoryPermission!
  
  repository: RepositoryInfo
}
type RepositoryInvitationConnection {
  
  edges: [RepositoryInvitationEdge]
  
  nodes: [RepositoryInvitation]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type RepositoryInvitationEdge {
  
  cursor: String!
  
  node: RepositoryInvitation
}
input RepositoryInvitationOrder {
  
  direction: OrderDirection!
  
  field: RepositoryInvitationOrderField!
}
enum RepositoryInvitationOrderField {
  
  CREATED_AT
  
  INVITEE_LOGIN @deprecated(reason: "`INVITEE_LOGIN` is no longer a valid field value. Repository invitations can now be associated with an email, not only an invitee. Removal on 2020-10-01 UTC.")
}
enum RepositoryLockReason {
  
  BILLING
  
  MIGRATING
  
  MOVING
  
  RENAME
}
interface RepositoryNode {
  
  repository: Repository!
}
input RepositoryOrder {
  
  direction: OrderDirection!
  
  field: RepositoryOrderField!
}
enum RepositoryOrderField {
  
  CREATED_AT
  
  NAME
  
  PUSHED_AT
  
  STARGAZERS
  
  UPDATED_AT
}
interface RepositoryOwner {
  
  avatarUrl(
    
    size: Int
  ): URI!
  id: ID!
  
  login: String!
  
  repositories(
    
    affiliations: [RepositoryAffiliation]
    
    after: String
    
    before: String
    
    first: Int
    
    isFork: Boolean
    
    isLocked: Boolean
    
    last: Int
    
    orderBy: RepositoryOrder
    
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  
  repository(
    
    name: String!
  ): Repository
  
  resourcePath: URI!
  
  url: URI!
}
enum RepositoryPermission {
  
  ADMIN
  
  MAINTAIN
  
  READ
  
  TRIAGE
  
  WRITE
}
enum RepositoryPrivacy {
  
  PRIVATE
  
  PUBLIC
}
type RepositoryTopic implements Node & UniformResourceLocatable {
  id: ID!
  
  resourcePath: URI!
  
  topic: Topic!
  
  url: URI!
}
type RepositoryTopicConnection {
  
  edges: [RepositoryTopicEdge]
  
  nodes: [RepositoryTopic]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type RepositoryTopicEdge {
  
  cursor: String!
  
  node: RepositoryTopic
}
enum RepositoryVisibility {
  
  INTERNAL
  
  PRIVATE
  
  PUBLIC
}
type RepositoryVisibilityChangeDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepositoryVisibilityChangeEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  
  enterpriseResourcePath: URI
  
  enterpriseSlug: String
  
  enterpriseUrl: URI
  id: ID!
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type RepositoryVulnerabilityAlert implements Node & RepositoryNode {
  
  createdAt: DateTime!
  
  dismissReason: String
  
  dismissedAt: DateTime
  
  dismisser: User
  id: ID!
  
  repository: Repository!
  
  securityAdvisory: SecurityAdvisory
  
  securityVulnerability: SecurityVulnerability
  
  vulnerableManifestFilename: String!
  
  vulnerableManifestPath: String!
  
  vulnerableRequirements: String
}
type RepositoryVulnerabilityAlertConnection {
  
  edges: [RepositoryVulnerabilityAlertEdge]
  
  nodes: [RepositoryVulnerabilityAlert]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type RepositoryVulnerabilityAlertEdge {
  
  cursor: String!
  
  node: RepositoryVulnerabilityAlert
}
input RequestReviewsInput {
  
  clientMutationId: String
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  
  teamIds: [ID!] @possibleTypes(concreteTypes: ["Team"])
  
  union: Boolean
  
  userIds: [ID!] @possibleTypes(concreteTypes: ["User"])
}
type RequestReviewsPayload {
  
  actor: Actor
  
  clientMutationId: String
  
  pullRequest: PullRequest
  
  requestedReviewersEdge: UserEdge
}
enum RequestableCheckStatusState {
  
  COMPLETED
  
  IN_PROGRESS
  
  QUEUED
}
union RequestedReviewer = Mannequin | Team | User
input RerequestCheckSuiteInput {
  
  checkSuiteId: ID! @possibleTypes(concreteTypes: ["CheckSuite"])
  
  clientMutationId: String
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type RerequestCheckSuitePayload {
  
  checkSuite: CheckSuite
  
  clientMutationId: String
}
input ResolveReviewThreadInput {
  
  clientMutationId: String
  
  threadId: ID! @possibleTypes(concreteTypes: ["PullRequestReviewThread"])
}
type ResolveReviewThreadPayload {
  
  clientMutationId: String
  
  thread: PullRequestReviewThread
}
type RestrictedContribution implements Contribution {
  
  isRestricted: Boolean!
  
  occurredAt: DateTime!
  
  resourcePath: URI!
  
  url: URI!
  
  user: User!
}
type ReviewDismissalAllowance implements Node {
  
  actor: ReviewDismissalAllowanceActor
  
  branchProtectionRule: BranchProtectionRule
  id: ID!
}
union ReviewDismissalAllowanceActor = Team | User
type ReviewDismissalAllowanceConnection {
  
  edges: [ReviewDismissalAllowanceEdge]
  
  nodes: [ReviewDismissalAllowance]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ReviewDismissalAllowanceEdge {
  
  cursor: String!
  
  node: ReviewDismissalAllowance
}
type ReviewDismissedEvent implements Node & UniformResourceLocatable {
  
  actor: Actor
  
  createdAt: DateTime!
  
  databaseId: Int
  
  dismissalMessage: String
  
  dismissalMessageHTML: String
  id: ID!
  
  previousReviewState: PullRequestReviewState!
  
  pullRequest: PullRequest!
  
  pullRequestCommit: PullRequestCommit
  
  resourcePath: URI!
  
  review: PullRequestReview
  
  url: URI!
}
type ReviewRequest implements Node {
  
  asCodeOwner: Boolean!
  
  databaseId: Int
  id: ID!
  
  pullRequest: PullRequest!
  
  requestedReviewer: RequestedReviewer
}
type ReviewRequestConnection {
  
  edges: [ReviewRequestEdge]
  
  nodes: [ReviewRequest]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type ReviewRequestEdge {
  
  cursor: String!
  
  node: ReviewRequest
}
type ReviewRequestRemovedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
  
  requestedReviewer: RequestedReviewer
}
type ReviewRequestedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  pullRequest: PullRequest!
  
  requestedReviewer: RequestedReviewer
}
type ReviewStatusHovercardContext implements HovercardContext {
  
  message: String!
  
  octicon: String!
  
  reviewDecision: PullRequestReviewDecision
}
enum SamlDigestAlgorithm {
  
  SHA1
  
  SHA256
  
  SHA384
  
  SHA512
}
enum SamlSignatureAlgorithm {
  
  RSA_SHA1
  
  RSA_SHA256
  
  RSA_SHA384
  
  RSA_SHA512
}
type SavedReply implements Node {
  
  body: String!
  
  bodyHTML: HTML!
  
  databaseId: Int
  id: ID!
  
  title: String!
  
  user: Actor
}
type SavedReplyConnection {
  
  edges: [SavedReplyEdge]
  
  nodes: [SavedReply]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type SavedReplyEdge {
  
  cursor: String!
  
  node: SavedReply
}
input SavedReplyOrder {
  
  direction: OrderDirection!
  
  field: SavedReplyOrderField!
}
enum SavedReplyOrderField {
  
  UPDATED_AT
}
union SearchResultItem = App | Issue | MarketplaceListing | Organization | PullRequest | Repository | User
type SearchResultItemConnection {
  
  codeCount: Int!
  
  edges: [SearchResultItemEdge]
  
  issueCount: Int!
  
  nodes: [SearchResultItem]
  
  pageInfo: PageInfo!
  
  repositoryCount: Int!
  
  userCount: Int!
  
  wikiCount: Int!
}
type SearchResultItemEdge {
  
  cursor: String!
  
  node: SearchResultItem
  
  textMatches: [TextMatch]
}
enum SearchType {
  
  ISSUE
  
  REPOSITORY
  
  USER
}
type SecurityAdvisory implements Node {
  
  databaseId: Int
  
  description: String!
  
  ghsaId: String!
  id: ID!
  
  identifiers: [SecurityAdvisoryIdentifier!]!
  
  origin: String!
  
  permalink: URI
  
  publishedAt: DateTime!
  
  references: [SecurityAdvisoryReference!]!
  
  severity: SecurityAdvisorySeverity!
  
  summary: String!
  
  updatedAt: DateTime!
  
  vulnerabilities(
    
    after: String
    
    before: String
    
    ecosystem: SecurityAdvisoryEcosystem
    
    first: Int
    
    last: Int
    
    orderBy: SecurityVulnerabilityOrder = {field: UPDATED_AT, direction: DESC}
    
    package: String
    
    severities: [SecurityAdvisorySeverity!]
  ): SecurityVulnerabilityConnection!
  
  withdrawnAt: DateTime
}
type SecurityAdvisoryConnection {
  
  edges: [SecurityAdvisoryEdge]
  
  nodes: [SecurityAdvisory]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
enum SecurityAdvisoryEcosystem {
  
  COMPOSER
  
  MAVEN
  
  NPM
  
  NUGET
  
  PIP
  
  RUBYGEMS
}
type SecurityAdvisoryEdge {
  
  cursor: String!
  
  node: SecurityAdvisory
}
type SecurityAdvisoryIdentifier {
  
  type: String!
  
  value: String!
}
input SecurityAdvisoryIdentifierFilter {
  
  type: SecurityAdvisoryIdentifierType!
  
  value: String!
}
enum SecurityAdvisoryIdentifierType {
  
  CVE
  
  GHSA
}
input SecurityAdvisoryOrder {
  
  direction: OrderDirection!
  
  field: SecurityAdvisoryOrderField!
}
enum SecurityAdvisoryOrderField {
  
  PUBLISHED_AT
  
  UPDATED_AT
}
type SecurityAdvisoryPackage {
  
  ecosystem: SecurityAdvisoryEcosystem!
  
  name: String!
}
type SecurityAdvisoryPackageVersion {
  
  identifier: String!
}
type SecurityAdvisoryReference {
  
  url: URI!
}
enum SecurityAdvisorySeverity {
  
  CRITICAL
  
  HIGH
  
  LOW
  
  MODERATE
}
type SecurityVulnerability {
  
  advisory: SecurityAdvisory!
  
  firstPatchedVersion: SecurityAdvisoryPackageVersion
  
  package: SecurityAdvisoryPackage!
  
  severity: SecurityAdvisorySeverity!
  
  updatedAt: DateTime!
  
  vulnerableVersionRange: String!
}
type SecurityVulnerabilityConnection {
  
  edges: [SecurityVulnerabilityEdge]
  
  nodes: [SecurityVulnerability]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type SecurityVulnerabilityEdge {
  
  cursor: String!
  
  node: SecurityVulnerability
}
input SecurityVulnerabilityOrder {
  
  direction: OrderDirection!
  
  field: SecurityVulnerabilityOrderField!
}
enum SecurityVulnerabilityOrderField {
  
  UPDATED_AT
}
input SetEnterpriseIdentityProviderInput {
  
  clientMutationId: String
  
  digestMethod: SamlDigestAlgorithm!
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  idpCertificate: String!
  
  issuer: String
  
  signatureMethod: SamlSignatureAlgorithm!
  
  ssoUrl: URI!
}
type SetEnterpriseIdentityProviderPayload {
  
  clientMutationId: String
  
  identityProvider: EnterpriseIdentityProvider
}
input SetOrganizationInteractionLimitInput {
  
  clientMutationId: String
  
  expiry: RepositoryInteractionLimitExpiry
  
  limit: RepositoryInteractionLimit!
  
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type SetOrganizationInteractionLimitPayload {
  
  clientMutationId: String
  
  organization: Organization
}
input SetRepositoryInteractionLimitInput {
  
  clientMutationId: String
  
  expiry: RepositoryInteractionLimitExpiry
  
  limit: RepositoryInteractionLimit!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type SetRepositoryInteractionLimitPayload {
  
  clientMutationId: String
  
  repository: Repository
}
input SetUserInteractionLimitInput {
  
  clientMutationId: String
  
  expiry: RepositoryInteractionLimitExpiry
  
  limit: RepositoryInteractionLimit!
  
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type SetUserInteractionLimitPayload {
  
  clientMutationId: String
  
  user: User
}
type SmimeSignature implements GitSignature {
  
  email: String!
  
  isValid: Boolean!
  
  payload: String!
  
  signature: String!
  
  signer: User
  
  state: GitSignatureState!
  
  wasSignedByGitHub: Boolean!
}
union Sponsor = Organization | User
interface Sponsorable {
  
  hasSponsorsListing: Boolean!
  
  isSponsoringViewer: Boolean!
  
  sponsorsListing: SponsorsListing
  
  sponsorshipsAsMaintainer(
    
    after: String
    
    before: String
    
    first: Int
    
    includePrivate: Boolean = false
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  
  sponsorshipsAsSponsor(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  
  viewerCanSponsor: Boolean!
  
  viewerIsSponsoring: Boolean!
}
type SponsorsListing implements Node {
  
  createdAt: DateTime!
  
  fullDescription: String!
  
  fullDescriptionHTML: HTML!
  id: ID!
  
  name: String!
  
  shortDescription: String!
  
  slug: String!
  
  tiers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: SponsorsTierOrder = {field: MONTHLY_PRICE_IN_CENTS, direction: ASC}
  ): SponsorsTierConnection
}
type SponsorsTier implements Node {
  
  adminInfo: SponsorsTierAdminInfo
  
  createdAt: DateTime!
  
  description: String!
  
  descriptionHTML: HTML!
  id: ID!
  
  monthlyPriceInCents: Int!
  
  monthlyPriceInDollars: Int!
  
  name: String!
  
  sponsorsListing: SponsorsListing!
  
  updatedAt: DateTime!
}
type SponsorsTierAdminInfo {
  
  sponsorships(
    
    after: String
    
    before: String
    
    first: Int
    
    includePrivate: Boolean = false
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
}
type SponsorsTierConnection {
  
  edges: [SponsorsTierEdge]
  
  nodes: [SponsorsTier]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type SponsorsTierEdge {
  
  cursor: String!
  
  node: SponsorsTier
}
input SponsorsTierOrder {
  
  direction: OrderDirection!
  
  field: SponsorsTierOrderField!
}
enum SponsorsTierOrderField {
  
  CREATED_AT
  
  MONTHLY_PRICE_IN_CENTS
}
type Sponsorship implements Node {
  
  createdAt: DateTime!
  id: ID!
  
  maintainer: User! @deprecated(reason: "`Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.")
  
  privacyLevel: SponsorshipPrivacy!
  
  sponsor: User @deprecated(reason: "`Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.")
  
  sponsorEntity: Sponsor
  
  sponsorable: Sponsorable!
  
  tier: SponsorsTier
}
type SponsorshipConnection {
  
  edges: [SponsorshipEdge]
  
  nodes: [Sponsorship]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type SponsorshipEdge {
  
  cursor: String!
  
  node: Sponsorship
}
input SponsorshipOrder {
  
  direction: OrderDirection!
  
  field: SponsorshipOrderField!
}
enum SponsorshipOrderField {
  
  CREATED_AT
}
enum SponsorshipPrivacy {
  
  PRIVATE
  
  PUBLIC
}
input StarOrder {
  
  direction: OrderDirection!
  
  field: StarOrderField!
}
enum StarOrderField {
  
  STARRED_AT
}
type StargazerConnection {
  
  edges: [StargazerEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type StargazerEdge {
  
  cursor: String!
  node: User!
  
  starredAt: DateTime!
}
interface Starrable {
  id: ID!
  
  stargazerCount: Int!
  
  stargazers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: StarOrder
  ): StargazerConnection!
  
  viewerHasStarred: Boolean!
}
type StarredRepositoryConnection {
  
  edges: [StarredRepositoryEdge]
  
  isOverLimit: Boolean!
  
  nodes: [Repository]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type StarredRepositoryEdge {
  
  cursor: String!
  node: Repository!
  
  starredAt: DateTime!
}
type Status implements Node {
  
  combinedContexts(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): StatusCheckRollupContextConnection!
  
  commit: Commit
  
  context(
    
    name: String!
  ): StatusContext
  
  contexts: [StatusContext!]!
  id: ID!
  
  state: StatusState!
}
type StatusCheckRollup implements Node {
  
  commit: Commit
  
  contexts(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): StatusCheckRollupContextConnection!
  id: ID!
  
  state: StatusState!
}
union StatusCheckRollupContext = CheckRun | StatusContext
type StatusCheckRollupContextConnection {
  
  edges: [StatusCheckRollupContextEdge]
  
  nodes: [StatusCheckRollupContext]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type StatusCheckRollupContextEdge {
  
  cursor: String!
  
  node: StatusCheckRollupContext
}
type StatusContext implements Node {
  
  avatarUrl(
    
    size: Int = 40
  ): URI
  
  commit: Commit
  
  context: String!
  
  createdAt: DateTime!
  
  creator: Actor
  
  description: String
  id: ID!
  
  state: StatusState!
  
  targetUrl: URI
}
enum StatusState {
  
  ERROR
  
  EXPECTED
  
  FAILURE
  
  PENDING
  
  SUCCESS
}
input SubmitPullRequestReviewInput {
  
  body: String
  
  clientMutationId: String
  
  event: PullRequestReviewEvent!
  
  pullRequestId: ID @possibleTypes(concreteTypes: ["PullRequest"])
  
  pullRequestReviewId: ID @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type SubmitPullRequestReviewPayload {
  
  clientMutationId: String
  
  pullRequestReview: PullRequestReview
}
type Submodule {
  
  branch: String
  
  gitUrl: URI!
  
  name: String!
  
  path: String!
  
  subprojectCommitOid: GitObjectID
}
type SubmoduleConnection {
  
  edges: [SubmoduleEdge]
  
  nodes: [Submodule]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type SubmoduleEdge {
  
  cursor: String!
  
  node: Submodule
}
interface Subscribable {
  id: ID!
  
  viewerCanSubscribe: Boolean!
  
  viewerSubscription: SubscriptionState
}
type SubscribedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  subscribable: Subscribable!
}
enum SubscriptionState {
  
  IGNORED
  
  SUBSCRIBED
  
  UNSUBSCRIBED
}
type SuggestedReviewer {
  
  isAuthor: Boolean!
  
  isCommenter: Boolean!
  
  reviewer: User!
}
type Tag implements GitObject & Node {
  
  abbreviatedOid: String!
  
  commitResourcePath: URI!
  
  commitUrl: URI!
  id: ID!
  
  message: String
  
  name: String!
  
  oid: GitObjectID!
  
  repository: Repository!
  
  tagger: GitActor
  
  target: GitObject!
}
type Team implements MemberStatusable & Node & Subscribable {
  
  ancestors(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): TeamConnection!
  
  avatarUrl(
    
    size: Int = 400
  ): URI
  
  childTeams(
    
    after: String
    
    before: String
    
    first: Int
    
    immediateOnly: Boolean = true
    
    last: Int
    
    orderBy: TeamOrder
    
    userLogins: [String!]
  ): TeamConnection!
  
  combinedSlug: String!
  
  createdAt: DateTime!
  
  databaseId: Int
  
  description: String
  
  discussion(
    
    number: Int!
  ): TeamDiscussion
  
  discussions(
    
    after: String
    
    before: String
    
    first: Int
    
    isPinned: Boolean
    
    last: Int
    
    orderBy: TeamDiscussionOrder
  ): TeamDiscussionConnection!
  
  discussionsResourcePath: URI!
  
  discussionsUrl: URI!
  
  editTeamResourcePath: URI!
  
  editTeamUrl: URI!
  id: ID!
  
  invitations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): OrganizationInvitationConnection
  
  memberStatuses(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
  
  members(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    membership: TeamMembershipType = ALL
    
    orderBy: TeamMemberOrder
    
    query: String
    
    role: TeamMemberRole
  ): TeamMemberConnection!
  
  membersResourcePath: URI!
  
  membersUrl: URI!
  
  name: String!
  
  newTeamResourcePath: URI!
  
  newTeamUrl: URI!
  
  organization: Organization!
  
  parentTeam: Team
  
  privacy: TeamPrivacy!
  
  repositories(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: TeamRepositoryOrder
    
    query: String
  ): TeamRepositoryConnection!
  
  repositoriesResourcePath: URI!
  
  repositoriesUrl: URI!
  
  resourcePath: URI!
  
  reviewRequestDelegationAlgorithm: TeamReviewAssignmentAlgorithm @preview(toggledBy: "stone-crop-preview")
  
  reviewRequestDelegationEnabled: Boolean! @preview(toggledBy: "stone-crop-preview")
  
  reviewRequestDelegationMemberCount: Int @preview(toggledBy: "stone-crop-preview")
  
  reviewRequestDelegationNotifyTeam: Boolean! @preview(toggledBy: "stone-crop-preview")
  
  slug: String!
  
  teamsResourcePath: URI!
  
  teamsUrl: URI!
  
  updatedAt: DateTime!
  
  url: URI!
  
  viewerCanAdminister: Boolean!
  
  viewerCanSubscribe: Boolean!
  
  viewerSubscription: SubscriptionState
}
type TeamAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  isLdapMapped: Boolean
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type TeamAddRepositoryAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  isLdapMapped: Boolean
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
interface TeamAuditEntryData {
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
}
type TeamChangeParentTeamAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  isLdapMapped: Boolean
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  parentTeam: Team
  
  parentTeamName: String
  
  parentTeamNameWas: String
  
  parentTeamResourcePath: URI
  
  parentTeamUrl: URI
  
  parentTeamWas: Team
  
  parentTeamWasResourcePath: URI
  
  parentTeamWasUrl: URI
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type TeamConnection {
  
  edges: [TeamEdge]
  
  nodes: [Team]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type TeamDiscussion implements Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  bodyVersion: String!
  
  comments(
    
    after: String
    
    before: String
    
    first: Int
    
    fromComment: Int
    
    last: Int
    
    orderBy: TeamDiscussionCommentOrder
  ): TeamDiscussionCommentConnection!
  
  commentsResourcePath: URI!
  
  commentsUrl: URI!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  isPinned: Boolean!
  
  isPrivate: Boolean!
  
  lastEditedAt: DateTime
  
  number: Int!
  
  publishedAt: DateTime
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  resourcePath: URI!
  
  team: Team!
  
  title: String!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanPin: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanSubscribe: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
  
  viewerSubscription: SubscriptionState
}
type TeamDiscussionComment implements Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment {
  
  author: Actor
  
  authorAssociation: CommentAuthorAssociation!
  
  body: String!
  
  bodyHTML: HTML!
  
  bodyText: String!
  
  bodyVersion: String!
  
  createdAt: DateTime!
  
  createdViaEmail: Boolean!
  
  databaseId: Int
  
  discussion: TeamDiscussion!
  
  editor: Actor
  id: ID!
  
  includesCreatedEdit: Boolean!
  
  lastEditedAt: DateTime
  
  number: Int!
  
  publishedAt: DateTime
  
  reactionGroups: [ReactionGroup!]
  
  reactions(
    
    after: String
    
    before: String
    
    content: ReactionContent
    
    first: Int
    
    last: Int
    
    orderBy: ReactionOrder
  ): ReactionConnection!
  
  resourcePath: URI!
  
  updatedAt: DateTime!
  
  url: URI!
  
  userContentEdits(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): UserContentEditConnection
  
  viewerCanDelete: Boolean!
  
  viewerCanReact: Boolean!
  
  viewerCanUpdate: Boolean!
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  
  viewerDidAuthor: Boolean!
}
type TeamDiscussionCommentConnection {
  
  edges: [TeamDiscussionCommentEdge]
  
  nodes: [TeamDiscussionComment]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type TeamDiscussionCommentEdge {
  
  cursor: String!
  
  node: TeamDiscussionComment
}
input TeamDiscussionCommentOrder {
  
  direction: OrderDirection!
  
  field: TeamDiscussionCommentOrderField!
}
enum TeamDiscussionCommentOrderField {
  
  NUMBER
}
type TeamDiscussionConnection {
  
  edges: [TeamDiscussionEdge]
  
  nodes: [TeamDiscussion]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type TeamDiscussionEdge {
  
  cursor: String!
  
  node: TeamDiscussion
}
input TeamDiscussionOrder {
  
  direction: OrderDirection!
  
  field: TeamDiscussionOrderField!
}
enum TeamDiscussionOrderField {
  
  CREATED_AT
}
type TeamEdge {
  
  cursor: String!
  
  node: Team
}
type TeamMemberConnection {
  
  edges: [TeamMemberEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type TeamMemberEdge {
  
  cursor: String!
  
  memberAccessResourcePath: URI!
  
  memberAccessUrl: URI!
  node: User!
  
  role: TeamMemberRole!
}
input TeamMemberOrder {
  
  direction: OrderDirection!
  
  field: TeamMemberOrderField!
}
enum TeamMemberOrderField {
  
  CREATED_AT
  
  LOGIN
}
enum TeamMemberRole {
  
  MAINTAINER
  
  MEMBER
}
enum TeamMembershipType {
  
  ALL
  
  CHILD_TEAM
  
  IMMEDIATE
}
input TeamOrder {
  
  direction: OrderDirection!
  
  field: TeamOrderField!
}
enum TeamOrderField {
  
  NAME
}
enum TeamPrivacy {
  
  SECRET
  
  VISIBLE
}
type TeamRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  isLdapMapped: Boolean
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type TeamRemoveRepositoryAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData {
  
  action: String!
  
  actor: AuditEntryActor
  
  actorIp: String
  
  actorLocation: ActorLocation
  
  actorLogin: String
  
  actorResourcePath: URI
  
  actorUrl: URI
  
  createdAt: PreciseDateTime!
  id: ID!
  
  isLdapMapped: Boolean
  
  operationType: OperationType
  
  organization: Organization
  
  organizationName: String
  
  organizationResourcePath: URI
  
  organizationUrl: URI
  
  repository: Repository
  
  repositoryName: String
  
  repositoryResourcePath: URI
  
  repositoryUrl: URI
  
  team: Team
  
  teamName: String
  
  teamResourcePath: URI
  
  teamUrl: URI
  
  user: User
  
  userLogin: String
  
  userResourcePath: URI
  
  userUrl: URI
}
type TeamRepositoryConnection {
  
  edges: [TeamRepositoryEdge]
  
  nodes: [Repository]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type TeamRepositoryEdge {
  
  cursor: String!
  node: Repository!
  
  permission: RepositoryPermission!
}
input TeamRepositoryOrder {
  
  direction: OrderDirection!
  
  field: TeamRepositoryOrderField!
}
enum TeamRepositoryOrderField {
  
  CREATED_AT
  
  NAME
  
  PERMISSION
  
  PUSHED_AT
  
  STARGAZERS
  
  UPDATED_AT
}
enum TeamReviewAssignmentAlgorithm @preview(toggledBy: "stone-crop-preview") {
  
  LOAD_BALANCE
  
  ROUND_ROBIN
}
enum TeamRole {
  
  ADMIN
  
  MEMBER
}
type TextMatch {
  
  fragment: String!
  
  highlights: [TextMatchHighlight!]!
  
  property: String!
}
type TextMatchHighlight {
  
  beginIndice: Int!
  
  endIndice: Int!
  
  text: String!
}
type Topic implements Node & Starrable {
  id: ID!
  
  name: String!
  
  relatedTopics(
    
    first: Int = 3
  ): [Topic!]!
  
  stargazerCount: Int!
  
  stargazers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: StarOrder
  ): StargazerConnection!
  
  viewerHasStarred: Boolean!
}
interface TopicAuditEntryData {
  
  topic: Topic
  
  topicName: String
}
enum TopicSuggestionDeclineReason {
  
  NOT_RELEVANT
  
  PERSONAL_PREFERENCE
  
  TOO_GENERAL
  
  TOO_SPECIFIC
}
input TransferIssueInput {
  
  clientMutationId: String
  
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type TransferIssuePayload {
  
  clientMutationId: String
  
  issue: Issue
}
type TransferredEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  
  fromRepository: Repository
  id: ID!
  
  issue: Issue!
}
type Tree implements GitObject & Node {
  
  abbreviatedOid: String!
  
  commitResourcePath: URI!
  
  commitUrl: URI!
  
  entries: [TreeEntry!]
  id: ID!
  
  oid: GitObjectID!
  
  repository: Repository!
}
type TreeEntry {
  
  extension: String
  
  isGenerated: Boolean!
  
  mode: Int!
  
  name: String!
  
  object: GitObject
  
  oid: GitObjectID!
  
  path: String
  
  repository: Repository!
  
  submodule: Submodule
  
  type: String!
}
scalar URI
input UnarchiveRepositoryInput {
  
  clientMutationId: String
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UnarchiveRepositoryPayload {
  
  clientMutationId: String
  
  repository: Repository
}
type UnassignedEvent implements Node {
  
  actor: Actor
  
  assignable: Assignable!
  
  assignee: Assignee
  
  createdAt: DateTime!
  id: ID!
  
  user: User @deprecated(reason: "Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.")
}
input UnfollowUserInput {
  
  clientMutationId: String
  
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type UnfollowUserPayload {
  
  clientMutationId: String
  
  user: User
}
interface UniformResourceLocatable {
  
  resourcePath: URI!
  
  url: URI!
}
type UnknownSignature implements GitSignature {
  
  email: String!
  
  isValid: Boolean!
  
  payload: String!
  
  signature: String!
  
  signer: User
  
  state: GitSignatureState!
  
  wasSignedByGitHub: Boolean!
}
type UnlabeledEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  label: Label!
  
  labelable: Labelable!
}
input UnlinkRepositoryFromProjectInput {
  
  clientMutationId: String
  
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UnlinkRepositoryFromProjectPayload {
  
  clientMutationId: String
  
  project: Project
  
  repository: Repository
}
input UnlockLockableInput {
  
  clientMutationId: String
  
  lockableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Lockable")
}
type UnlockLockablePayload {
  
  actor: Actor
  
  clientMutationId: String
  
  unlockedRecord: Lockable
}
type UnlockedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  lockable: Lockable!
}
input UnmarkFileAsViewedInput {
  
  clientMutationId: String
  
  path: String!
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type UnmarkFileAsViewedPayload {
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
input UnmarkIssueAsDuplicateInput {
  
  canonicalId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "IssueOrPullRequest")
  
  clientMutationId: String
  
  duplicateId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "IssueOrPullRequest")
}
type UnmarkIssueAsDuplicatePayload {
  
  clientMutationId: String
  
  duplicate: IssueOrPullRequest
}
type UnmarkedAsDuplicateEvent implements Node {
  
  actor: Actor
  
  canonical: IssueOrPullRequest
  
  createdAt: DateTime!
  
  duplicate: IssueOrPullRequest
  id: ID!
  
  isCrossRepository: Boolean!
}
input UnminimizeCommentInput {
  
  clientMutationId: String
  
  subjectId: ID! @possibleTypes(concreteTypes: ["CommitComment", "GistComment", "IssueComment", "PullRequestReviewComment"], abstractType: "Minimizable")
}
type UnminimizeCommentPayload {
  
  clientMutationId: String
  
  unminimizedComment: Minimizable
}
input UnpinIssueInput {
  
  clientMutationId: String
  
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type UnpinIssuePayload {
  
  clientMutationId: String
  
  issue: Issue
}
type UnpinnedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  issue: Issue!
}
input UnresolveReviewThreadInput {
  
  clientMutationId: String
  
  threadId: ID! @possibleTypes(concreteTypes: ["PullRequestReviewThread"])
}
type UnresolveReviewThreadPayload {
  
  clientMutationId: String
  
  thread: PullRequestReviewThread
}
type UnsubscribedEvent implements Node {
  
  actor: Actor
  
  createdAt: DateTime!
  id: ID!
  
  subscribable: Subscribable!
}
interface Updatable {
  
  viewerCanUpdate: Boolean!
}
interface UpdatableComment {
  
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
}
input UpdateBranchProtectionRuleInput {
  
  allowsDeletions: Boolean
  
  allowsForcePushes: Boolean
  
  branchProtectionRuleId: ID! @possibleTypes(concreteTypes: ["BranchProtectionRule"])
  
  clientMutationId: String
  
  dismissesStaleReviews: Boolean
  
  isAdminEnforced: Boolean
  
  pattern: String
  
  pushActorIds: [ID!]
  
  requiredApprovingReviewCount: Int
  
  requiredStatusCheckContexts: [String!]
  
  requiresApprovingReviews: Boolean
  
  requiresCodeOwnerReviews: Boolean
  
  requiresCommitSignatures: Boolean
  
  requiresLinearHistory: Boolean
  
  requiresStatusChecks: Boolean
  
  requiresStrictStatusChecks: Boolean
  
  restrictsPushes: Boolean
  
  restrictsReviewDismissals: Boolean
  
  reviewDismissalActorIds: [ID!]
}
type UpdateBranchProtectionRulePayload {
  
  branchProtectionRule: BranchProtectionRule
  
  clientMutationId: String
}
input UpdateCheckRunInput {
  
  actions: [CheckRunAction!]
  
  checkRunId: ID! @possibleTypes(concreteTypes: ["CheckRun"])
  
  clientMutationId: String
  
  completedAt: DateTime
  
  conclusion: CheckConclusionState
  
  detailsUrl: URI
  
  externalId: String
  
  name: String
  
  output: CheckRunOutput
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  startedAt: DateTime
  
  status: RequestableCheckStatusState
}
type UpdateCheckRunPayload {
  
  checkRun: CheckRun
  
  clientMutationId: String
}
input UpdateCheckSuitePreferencesInput {
  
  autoTriggerPreferences: [CheckSuiteAutoTriggerPreference!]!
  
  clientMutationId: String
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UpdateCheckSuitePreferencesPayload {
  
  clientMutationId: String
  
  repository: Repository
}
input UpdateEnterpriseAdministratorRoleInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  login: String!
  
  role: EnterpriseAdministratorRole!
}
type UpdateEnterpriseAdministratorRolePayload {
  
  clientMutationId: String
  
  message: String
}
input UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue!
}
type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  membersCanCreateInternalRepositories: Boolean
  
  membersCanCreatePrivateRepositories: Boolean
  
  membersCanCreatePublicRepositories: Boolean
  
  membersCanCreateRepositoriesPolicyEnabled: Boolean
  
  settingValue: EnterpriseMembersCanCreateRepositoriesSettingValue
}
type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue!
}
type UpdateEnterpriseMembersCanMakePurchasesSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseOrganizationProjectsSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseOrganizationProjectsSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseProfileInput {
  
  clientMutationId: String
  
  description: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  location: String
  
  name: String
  
  websiteUrl: String
}
type UpdateEnterpriseProfilePayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
}
input UpdateEnterpriseRepositoryProjectsSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseRepositoryProjectsSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseTeamDiscussionsSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseTeamDiscussionsSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  
  clientMutationId: String
  
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  
  settingValue: EnterpriseEnabledSettingValue!
}
type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload {
  
  clientMutationId: String
  
  enterprise: Enterprise
  
  message: String
}
input UpdateIpAllowListEnabledSettingInput {
  
  clientMutationId: String
  
  ownerId: ID! @possibleTypes(concreteTypes: ["Enterprise", "Organization"], abstractType: "IpAllowListOwner")
  
  settingValue: IpAllowListEnabledSettingValue!
}
type UpdateIpAllowListEnabledSettingPayload {
  
  clientMutationId: String
  
  owner: IpAllowListOwner
}
input UpdateIpAllowListEntryInput {
  
  allowListValue: String!
  
  clientMutationId: String
  
  ipAllowListEntryId: ID! @possibleTypes(concreteTypes: ["IpAllowListEntry"])
  
  isActive: Boolean!
  
  name: String
}
type UpdateIpAllowListEntryPayload {
  
  clientMutationId: String
  
  ipAllowListEntry: IpAllowListEntry
}
input UpdateIssueCommentInput {
  
  body: String!
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["IssueComment"])
}
type UpdateIssueCommentPayload {
  
  clientMutationId: String
  
  issueComment: IssueComment
}
input UpdateIssueInput {
  
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  
  body: String
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["Issue"])
  
  labelIds: [ID!] @possibleTypes(concreteTypes: ["Label"])
  
  milestoneId: ID @possibleTypes(concreteTypes: ["Milestone"])
  
  projectIds: [ID!]
  
  state: IssueState
  
  title: String
}
type UpdateIssuePayload {
  
  actor: Actor
  
  clientMutationId: String
  
  issue: Issue
}
input UpdateLabelInput @preview(toggledBy: "bane-preview") {
  
  clientMutationId: String
  
  color: String
  
  description: String
  
  id: ID! @possibleTypes(concreteTypes: ["Label"])
  
  name: String
}
type UpdateLabelPayload @preview(toggledBy: "bane-preview") {
  
  clientMutationId: String
  
  label: Label
}
input UpdateProjectCardInput {
  
  clientMutationId: String
  
  isArchived: Boolean
  
  note: String
  
  projectCardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
}
type UpdateProjectCardPayload {
  
  clientMutationId: String
  
  projectCard: ProjectCard
}
input UpdateProjectColumnInput {
  
  clientMutationId: String
  
  name: String!
  
  projectColumnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type UpdateProjectColumnPayload {
  
  clientMutationId: String
  
  projectColumn: ProjectColumn
}
input UpdateProjectInput {
  
  body: String
  
  clientMutationId: String
  
  name: String
  
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
  
  public: Boolean
  
  state: ProjectState
}
type UpdateProjectPayload {
  
  clientMutationId: String
  
  project: Project
}
input UpdatePullRequestInput {
  
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  
  baseRefName: String
  
  body: String
  
  clientMutationId: String
  
  labelIds: [ID!] @possibleTypes(concreteTypes: ["Label"])
  
  maintainerCanModify: Boolean
  
  milestoneId: ID @possibleTypes(concreteTypes: ["Milestone"])
  
  projectIds: [ID!]
  
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  
  state: PullRequestUpdateState
  
  title: String
}
type UpdatePullRequestPayload {
  
  actor: Actor
  
  clientMutationId: String
  
  pullRequest: PullRequest
}
input UpdatePullRequestReviewCommentInput {
  
  body: String!
  
  clientMutationId: String
  
  pullRequestReviewCommentId: ID! @possibleTypes(concreteTypes: ["PullRequestReviewComment"])
}
type UpdatePullRequestReviewCommentPayload {
  
  clientMutationId: String
  
  pullRequestReviewComment: PullRequestReviewComment
}
input UpdatePullRequestReviewInput {
  
  body: String!
  
  clientMutationId: String
  
  pullRequestReviewId: ID! @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type UpdatePullRequestReviewPayload {
  
  clientMutationId: String
  
  pullRequestReview: PullRequestReview
}
input UpdateRefInput {
  
  clientMutationId: String
  
  force: Boolean = false
  
  oid: GitObjectID!
  
  refId: ID! @possibleTypes(concreteTypes: ["Ref"])
}
type UpdateRefPayload {
  
  clientMutationId: String
  
  ref: Ref
}
input UpdateRefsInput @preview(toggledBy: "update-refs-preview") {
  
  clientMutationId: String
  
  refUpdates: [RefUpdate!]!
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UpdateRefsPayload @preview(toggledBy: "update-refs-preview") {
  
  clientMutationId: String
}
input UpdateRepositoryInput {
  
  clientMutationId: String
  
  description: String
  
  hasIssuesEnabled: Boolean
  
  hasProjectsEnabled: Boolean
  
  hasWikiEnabled: Boolean
  
  homepageUrl: URI
  
  name: String
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  template: Boolean
}
type UpdateRepositoryPayload {
  
  clientMutationId: String
  
  repository: Repository
}
input UpdateSubscriptionInput {
  
  clientMutationId: String
  
  state: SubscriptionState!
  
  subscribableId: ID! @possibleTypes(concreteTypes: ["Commit", "Issue", "PullRequest", "Repository", "Team", "TeamDiscussion"], abstractType: "Subscribable")
}
type UpdateSubscriptionPayload {
  
  clientMutationId: String
  
  subscribable: Subscribable
}
input UpdateTeamDiscussionCommentInput {
  
  body: String!
  
  bodyVersion: String
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussionComment"])
}
type UpdateTeamDiscussionCommentPayload {
  
  clientMutationId: String
  
  teamDiscussionComment: TeamDiscussionComment
}
input UpdateTeamDiscussionInput {
  
  body: String
  
  bodyVersion: String
  
  clientMutationId: String
  
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussion"])
  
  pinned: Boolean
  
  title: String
}
type UpdateTeamDiscussionPayload {
  
  clientMutationId: String
  
  teamDiscussion: TeamDiscussion
}
input UpdateTeamReviewAssignmentInput @preview(toggledBy: "stone-crop-preview") {
  
  algorithm: TeamReviewAssignmentAlgorithm = ROUND_ROBIN
  
  clientMutationId: String
  
  enabled: Boolean!
  
  excludedTeamMemberIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  
  id: ID! @possibleTypes(concreteTypes: ["Team"])
  
  notifyTeam: Boolean = true
  
  teamMemberCount: Int = 1
}
type UpdateTeamReviewAssignmentPayload {
  
  clientMutationId: String
  
  team: Team
}
input UpdateTopicsInput {
  
  clientMutationId: String
  
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  
  topicNames: [String!]!
}
type UpdateTopicsPayload {
  
  clientMutationId: String
  
  invalidTopicNames: [String!]
  
  repository: Repository
}
type User implements Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  
  anyPinnableItems(
    
    type: PinnableItemType
  ): Boolean!
  
  avatarUrl(
    
    size: Int
  ): URI!
  
  bio: String
  
  bioHTML: HTML!
  
  commitComments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): CommitCommentConnection!
  
  company: String
  
  companyHTML: HTML!
  
  contributionsCollection(
    
    from: DateTime
    
    organizationID: ID
    
    to: DateTime
  ): ContributionsCollection!
  
  createdAt: DateTime!
  
  databaseId: Int
  
  email: String!
  
  followers(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): FollowerConnection!
  
  following(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): FollowingConnection!
  
  gist(
    
    name: String!
  ): Gist
  
  gistComments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): GistCommentConnection!
  
  gists(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: GistOrder
    
    privacy: GistPrivacy
  ): GistConnection!
  
  hasSponsorsListing: Boolean!
  
  hovercard(
    
    primarySubjectId: ID
  ): Hovercard!
  id: ID!
  
  interactionAbility: RepositoryInteractionAbility
  
  isBountyHunter: Boolean!
  
  isCampusExpert: Boolean!
  
  isDeveloperProgramMember: Boolean!
  
  isEmployee: Boolean!
  
  isHireable: Boolean!
  
  isSiteAdmin: Boolean!
  
  isSponsoringViewer: Boolean!
  
  isViewer: Boolean!
  
  issueComments(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: IssueCommentOrder
  ): IssueCommentConnection!
  
  issues(
    
    after: String
    
    before: String
    
    filterBy: IssueFilters
    
    first: Int
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [IssueState!]
  ): IssueConnection!
  
  itemShowcase: ProfileItemShowcase!
  
  location: String
  
  login: String!
  
  name: String
  
  organization(
    
    login: String!
  ): Organization
  
  organizationVerifiedDomainEmails(
    
    login: String!
  ): [String!]!
  
  organizations(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): OrganizationConnection!
  
  packages(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    names: [String]
    
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    
    packageType: PackageType
    
    repositoryId: ID
  ): PackageConnection!
  
  pinnableItems(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  
  pinnedItems(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  
  pinnedItemsRemaining: Int!
  
  project(
    
    number: Int!
  ): Project
  
  projects(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: ProjectOrder
    
    search: String
    
    states: [ProjectState!]
  ): ProjectConnection!
  
  projectsResourcePath: URI!
  
  projectsUrl: URI!
  
  publicKeys(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
  ): PublicKeyConnection!
  
  pullRequests(
    
    after: String
    
    baseRefName: String
    
    before: String
    
    first: Int
    
    headRefName: String
    
    labels: [String!]
    
    last: Int
    
    orderBy: IssueOrder
    
    states: [PullRequestState!]
  ): PullRequestConnection!
  
  repositories(
    
    affiliations: [RepositoryAffiliation]
    
    after: String
    
    before: String
    
    first: Int
    
    isFork: Boolean
    
    isLocked: Boolean
    
    last: Int
    
    orderBy: RepositoryOrder
    
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  
  repositoriesContributedTo(
    
    after: String
    
    before: String
    
    contributionTypes: [RepositoryContributionType]
    
    first: Int
    
    includeUserRepositories: Boolean
    
    isLocked: Boolean
    
    last: Int
    
    orderBy: RepositoryOrder
    
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  
  repository(
    
    name: String!
  ): Repository
  
  resourcePath: URI!
  
  savedReplies(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: SavedReplyOrder = {field: UPDATED_AT, direction: DESC}
  ): SavedReplyConnection
  
  sponsorsListing: SponsorsListing
  
  sponsorshipsAsMaintainer(
    
    after: String
    
    before: String
    
    first: Int
    
    includePrivate: Boolean = false
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  
  sponsorshipsAsSponsor(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  
  starredRepositories(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: StarOrder
    
    ownedByViewer: Boolean
  ): StarredRepositoryConnection!
  
  status: UserStatus
  
  topRepositories(
    
    after: String
    
    before: String
    
    first: Int
    
    last: Int
    
    orderBy: RepositoryOrder!
    
    since: DateTime
  ): RepositoryConnection!
  
  twitterUsername: String
  
  updatedAt: DateTime!
  
  url: URI!
  
  viewerCanChangePinnedItems: Boolean!
  
  viewerCanCreateProjects: Boolean!
  
  viewerCanFollow: Boolean!
  
  viewerCanSponsor: Boolean!
  
  viewerIsFollowing: Boolean!
  
  viewerIsSponsoring: Boolean!
  
  watching(
    
    affiliations: [RepositoryAffiliation]
    
    after: String
    
    before: String
    
    first: Int
    
    isLocked: Boolean
    
    last: Int
    
    orderBy: RepositoryOrder
    
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  
  websiteUrl: URI
}
enum UserBlockDuration {
  
  ONE_DAY
  
  ONE_MONTH
  
  ONE_WEEK
  
  PERMANENT
  
  THREE_DAYS
}
type UserBlockedEvent implements Node {
  
  actor: Actor
  
  blockDuration: UserBlockDuration!
  
  createdAt: DateTime!
  id: ID!
  
  subject: User
}
type UserConnection {
  
  edges: [UserEdge]
  
  nodes: [User]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type UserContentEdit implements Node {
  
  createdAt: DateTime!
  
  deletedAt: DateTime
  
  deletedBy: Actor
  
  diff: String
  
  editedAt: DateTime!
  
  editor: Actor
  id: ID!
  
  updatedAt: DateTime!
}
type UserContentEditConnection {
  
  edges: [UserContentEditEdge]
  
  nodes: [UserContentEdit]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type UserContentEditEdge {
  
  cursor: String!
  
  node: UserContentEdit
}
type UserEdge {
  
  cursor: String!
  
  node: User
}
type UserEmailMetadata {
  
  primary: Boolean
  
  type: String
  
  value: String!
}
type UserStatus implements Node {
  
  createdAt: DateTime!
  
  emoji: String
  
  emojiHTML: HTML
  
  expiresAt: DateTime
  
  id: ID!
  
  indicatesLimitedAvailability: Boolean!
  
  message: String
  
  organization: Organization
  
  updatedAt: DateTime!
  
  user: User!
}
type UserStatusConnection {
  
  edges: [UserStatusEdge]
  
  nodes: [UserStatus]
  
  pageInfo: PageInfo!
  
  totalCount: Int!
}
type UserStatusEdge {
  
  cursor: String!
  
  node: UserStatus
}
input UserStatusOrder {
  
  direction: OrderDirection!
  
  field: UserStatusOrderField!
}
enum UserStatusOrderField {
  
  UPDATED_AT
}
type ViewerHovercardContext implements HovercardContext {
  
  message: String!
  
  octicon: String!
  
  viewer: User!
}
scalar X509Certificate
